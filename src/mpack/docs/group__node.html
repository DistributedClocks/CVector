<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MPack: Node API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-mpack-css.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MPack
   &#160;<span id="projectnumber">0.8.2</span>
   </div>
   <div id="projectbrief">A C encoding/decoding library for the MessagePack serialization format.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Node API</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The MPack Node API allows you to parse a chunk of MessagePack data in-place into a dynamically typed data structure. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga37218aec593259aed8b28625ff1395fb"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__node.html#ga37218aec593259aed8b28625ff1395fb">mpack_node_data_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga37218aec593259aed8b28625ff1395fb">mpack_node_data_t</a></td></tr>
<tr class="memdesc:ga37218aec593259aed8b28625ff1395fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The storage for nodes in an MPack tree.  <a href="#ga37218aec593259aed8b28625ff1395fb">More...</a><br /></td></tr>
<tr class="separator:ga37218aec593259aed8b28625ff1395fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08f46371c0c59a2e4dd7bdf1891fb3cb"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a></td></tr>
<tr class="memdesc:ga08f46371c0c59a2e4dd7bdf1891fb3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle to node data in a parsed MPack tree.  <a href="#ga08f46371c0c59a2e4dd7bdf1891fb3cb">More...</a><br /></td></tr>
<tr class="separator:ga08f46371c0c59a2e4dd7bdf1891fb3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga184ff3fbec66290ec72caf0abc8f3594"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga184ff3fbec66290ec72caf0abc8f3594">mpack_tree_error_t</a>) (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td></tr>
<tr class="memdesc:ga184ff3fbec66290ec72caf0abc8f3594"><td class="mdescLeft">&#160;</td><td class="mdescRight">An error handler function to be called when an error is flagged on the tree.  <a href="#ga184ff3fbec66290ec72caf0abc8f3594">More...</a><br /></td></tr>
<tr class="separator:ga184ff3fbec66290ec72caf0abc8f3594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c76cfdb08042d6412b5c745bca928a7"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a></td></tr>
<tr class="memdesc:ga9c76cfdb08042d6412b5c745bca928a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">An MPack tree parsed from a blob of MessagePack.  <a href="#ga9c76cfdb08042d6412b5c745bca928a7">More...</a><br /></td></tr>
<tr class="separator:ga9c76cfdb08042d6412b5c745bca928a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ca1eb6735624e7d98d64ac77b525c55"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga1ca1eb6735624e7d98d64ac77b525c55">mpack_tree_teardown_t</a>) (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree)</td></tr>
<tr class="memdesc:ga1ca1eb6735624e7d98d64ac77b525c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">A teardown function to be called when the tree is destroyed.  <a href="#ga1ca1eb6735624e7d98d64ac77b525c55">More...</a><br /></td></tr>
<tr class="separator:ga1ca1eb6735624e7d98d64ac77b525c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Tree Functions</h2></td></tr>
<tr class="memitem:ga57182f50afa56ca6a912620e894ed7c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga57182f50afa56ca6a912620e894ed7c3">mpack_tree_init</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, const char *data, size_t length)</td></tr>
<tr class="memdesc:ga57182f50afa56ca6a912620e894ed7c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a tree by parsing the given data buffer.  <a href="#ga57182f50afa56ca6a912620e894ed7c3">More...</a><br /></td></tr>
<tr class="separator:ga57182f50afa56ca6a912620e894ed7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cb51d3adfadc336a2ac28605a939a83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga3cb51d3adfadc336a2ac28605a939a83">mpack_tree_init_pool</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, const char *data, size_t length, <a class="el" href="group__node.html#ga37218aec593259aed8b28625ff1395fb">mpack_node_data_t</a> *node_pool, size_t node_pool_count)</td></tr>
<tr class="memdesc:ga3cb51d3adfadc336a2ac28605a939a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a tree by parsing the given data buffer, using the given node data pool to store the results.  <a href="#ga3cb51d3adfadc336a2ac28605a939a83">More...</a><br /></td></tr>
<tr class="separator:ga3cb51d3adfadc336a2ac28605a939a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8360ae0ff58c0b6fb5c5997297b602c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gad8360ae0ff58c0b6fb5c5997297b602c">mpack_tree_init_error</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td></tr>
<tr class="memdesc:gad8360ae0ff58c0b6fb5c5997297b602c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes an MPack tree directly into an error state.  <a href="#gad8360ae0ff58c0b6fb5c5997297b602c">More...</a><br /></td></tr>
<tr class="separator:gad8360ae0ff58c0b6fb5c5997297b602c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f8327cf4ebc79d9358ee0a1643af66c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga2f8327cf4ebc79d9358ee0a1643af66c">mpack_tree_init_file</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, const char *filename, size_t max_bytes)</td></tr>
<tr class="memdesc:ga2f8327cf4ebc79d9358ee0a1643af66c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a tree by reading and parsing the given file.  <a href="#ga2f8327cf4ebc79d9358ee0a1643af66c">More...</a><br /></td></tr>
<tr class="separator:ga2f8327cf4ebc79d9358ee0a1643af66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c49262ce28699d5ec90db09b5fd2eee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga2c49262ce28699d5ec90db09b5fd2eee">mpack_tree_root</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree)</td></tr>
<tr class="memdesc:ga2c49262ce28699d5ec90db09b5fd2eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the root node of the tree, if the tree is not in an error state.  <a href="#ga2c49262ce28699d5ec90db09b5fd2eee">More...</a><br /></td></tr>
<tr class="separator:ga2c49262ce28699d5ec90db09b5fd2eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac62f4d7bfac176dd636924f201cc4712"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gac62f4d7bfac176dd636924f201cc4712">mpack_tree_error</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree)</td></tr>
<tr class="memdesc:gac62f4d7bfac176dd636924f201cc4712"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error state of the tree.  <a href="#gac62f4d7bfac176dd636924f201cc4712">More...</a><br /></td></tr>
<tr class="separator:gac62f4d7bfac176dd636924f201cc4712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21aac296233a8a52d75cf7a1c57dd78f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga21aac296233a8a52d75cf7a1c57dd78f">mpack_tree_size</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree)</td></tr>
<tr class="memdesc:ga21aac296233a8a52d75cf7a1c57dd78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes used in the buffer when the tree was parsed.  <a href="#ga21aac296233a8a52d75cf7a1c57dd78f">More...</a><br /></td></tr>
<tr class="separator:ga21aac296233a8a52d75cf7a1c57dd78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf57acbc8356be8fab13a64f78986fdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gabf57acbc8356be8fab13a64f78986fdc">mpack_tree_destroy</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree)</td></tr>
<tr class="memdesc:gabf57acbc8356be8fab13a64f78986fdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the tree.  <a href="#gabf57acbc8356be8fab13a64f78986fdc">More...</a><br /></td></tr>
<tr class="separator:gabf57acbc8356be8fab13a64f78986fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad3dea301d544aa434ca661ef3b913d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gaad3dea301d544aa434ca661ef3b913d1">mpack_tree_set_context</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, void *context)</td></tr>
<tr class="memdesc:gaad3dea301d544aa434ca661ef3b913d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the custom pointer to pass to the tree callbacks, such as teardown.  <a href="#gaad3dea301d544aa434ca661ef3b913d1">More...</a><br /></td></tr>
<tr class="separator:gaad3dea301d544aa434ca661ef3b913d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dcb3d1c5b6d0f00223ff2a7b7fb36f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga9dcb3d1c5b6d0f00223ff2a7b7fb36f3">mpack_tree_set_error_handler</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, <a class="el" href="group__node.html#ga184ff3fbec66290ec72caf0abc8f3594">mpack_tree_error_t</a> error_fn)</td></tr>
<tr class="memdesc:ga9dcb3d1c5b6d0f00223ff2a7b7fb36f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the error function to call when an error is flagged on the tree.  <a href="#ga9dcb3d1c5b6d0f00223ff2a7b7fb36f3">More...</a><br /></td></tr>
<tr class="separator:ga9dcb3d1c5b6d0f00223ff2a7b7fb36f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfbf5d62990974e24f8abfed38c554e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gabfbf5d62990974e24f8abfed38c554e7">mpack_tree_set_teardown</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, <a class="el" href="group__node.html#ga1ca1eb6735624e7d98d64ac77b525c55">mpack_tree_teardown_t</a> teardown)</td></tr>
<tr class="memdesc:gabfbf5d62990974e24f8abfed38c554e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the teardown function to call when the tree is destroyed.  <a href="#gabfbf5d62990974e24f8abfed38c554e7">More...</a><br /></td></tr>
<tr class="separator:gabfbf5d62990974e24f8abfed38c554e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46fdd2e384e7399f07a600e13962a492"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga46fdd2e384e7399f07a600e13962a492">mpack_tree_flag_error</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td></tr>
<tr class="memdesc:ga46fdd2e384e7399f07a600e13962a492"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places the tree in the given error state, calling the error callback if one is set.  <a href="#ga46fdd2e384e7399f07a600e13962a492">More...</a><br /></td></tr>
<tr class="separator:ga46fdd2e384e7399f07a600e13962a492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46d2b3688954e32cb81268f982362036"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga46d2b3688954e32cb81268f982362036">mpack_node_flag_error</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td></tr>
<tr class="memdesc:ga46d2b3688954e32cb81268f982362036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Places the node's tree in the given error state, calling the error callback if one is set.  <a href="#ga46d2b3688954e32cb81268f982362036">More...</a><br /></td></tr>
<tr class="separator:ga46d2b3688954e32cb81268f982362036"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Node Core Functions</h2></td></tr>
<tr class="memitem:ga50003b22aceb00adfa11cd382a9eb7e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga50003b22aceb00adfa11cd382a9eb7e1">mpack_node_error</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:ga50003b22aceb00adfa11cd382a9eb7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the error state of the node's tree.  <a href="#ga50003b22aceb00adfa11cd382a9eb7e1">More...</a><br /></td></tr>
<tr class="separator:ga50003b22aceb00adfa11cd382a9eb7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bafb2aa97ea8ce8f517303329236b2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#structmpack__tag__t">mpack_tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga9bafb2aa97ea8ce8f517303329236b2c">mpack_node_tag</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:ga9bafb2aa97ea8ce8f517303329236b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a tag describing the given node, or a nil tag if the tree is in an error state.  <a href="#ga9bafb2aa97ea8ce8f517303329236b2c">More...</a><br /></td></tr>
<tr class="separator:ga9bafb2aa97ea8ce8f517303329236b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa405ce9d3f8739ee56fe6ca50a169543"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gaa405ce9d3f8739ee56fe6ca50a169543">mpack_node_print_file</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, FILE *file)</td></tr>
<tr class="memdesc:gaa405ce9d3f8739ee56fe6ca50a169543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a node to pseudo-JSON for debugging purposes and pretty-prints it to the given file.  <a href="#gaa405ce9d3f8739ee56fe6ca50a169543">More...</a><br /></td></tr>
<tr class="separator:gaa405ce9d3f8739ee56fe6ca50a169543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad244551de13bd2574fb0fe7da6ba5fdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gad244551de13bd2574fb0fe7da6ba5fdd">mpack_node_print</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:gad244551de13bd2574fb0fe7da6ba5fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a node to pseudo-JSON for debugging purposes and pretty-prints it to stdout.  <a href="#gad244551de13bd2574fb0fe7da6ba5fdd">More...</a><br /></td></tr>
<tr class="separator:gad244551de13bd2574fb0fe7da6ba5fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Node Primitive Value Functions</h2></td></tr>
<tr class="memitem:gabf769643817c3d88f98cc40801fba2eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga22f03cf1240d5a917e1b3e7be8ab327e">mpack_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gabf769643817c3d88f98cc40801fba2eb">mpack_node_type</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:gabf769643817c3d88f98cc40801fba2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the type of the node.  <a href="#gabf769643817c3d88f98cc40801fba2eb">More...</a><br /></td></tr>
<tr class="separator:gabf769643817c3d88f98cc40801fba2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42f4b9aebd9d612b1e5073490a4abba4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga42f4b9aebd9d612b1e5073490a4abba4">mpack_node_nil</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:ga42f4b9aebd9d612b1e5073490a4abba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given node is of nil type, raising mpack_error_type otherwise.  <a href="#ga42f4b9aebd9d612b1e5073490a4abba4">More...</a><br /></td></tr>
<tr class="separator:ga42f4b9aebd9d612b1e5073490a4abba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad15f3dba3fe1c0b5b7d9ed5d2c34215a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gad15f3dba3fe1c0b5b7d9ed5d2c34215a">mpack_node_bool</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:gad15f3dba3fe1c0b5b7d9ed5d2c34215a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bool value of the node.  <a href="#gad15f3dba3fe1c0b5b7d9ed5d2c34215a">More...</a><br /></td></tr>
<tr class="separator:gad15f3dba3fe1c0b5b7d9ed5d2c34215a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab54c26f5fc03f73b02070a72610c9127"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gab54c26f5fc03f73b02070a72610c9127">mpack_node_true</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:gab54c26f5fc03f73b02070a72610c9127"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given node is of bool type with value true, raising mpack_error_type otherwise.  <a href="#gab54c26f5fc03f73b02070a72610c9127">More...</a><br /></td></tr>
<tr class="separator:gab54c26f5fc03f73b02070a72610c9127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc37f432559b3b4be52e91e66a09f57d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gabc37f432559b3b4be52e91e66a09f57d">mpack_node_false</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:gabc37f432559b3b4be52e91e66a09f57d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given node is of bool type with value false, raising mpack_error_type otherwise.  <a href="#gabc37f432559b3b4be52e91e66a09f57d">More...</a><br /></td></tr>
<tr class="separator:gabc37f432559b3b4be52e91e66a09f57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad54f9c1d4bfdb0ae572782c4307d475f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gad54f9c1d4bfdb0ae572782c4307d475f">mpack_node_u8</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:gad54f9c1d4bfdb0ae572782c4307d475f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 8-bit unsigned value of the node.  <a href="#gad54f9c1d4bfdb0ae572782c4307d475f">More...</a><br /></td></tr>
<tr class="separator:gad54f9c1d4bfdb0ae572782c4307d475f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bc29e58ae03edd0d764eac30b6ab38a"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga5bc29e58ae03edd0d764eac30b6ab38a">mpack_node_i8</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:ga5bc29e58ae03edd0d764eac30b6ab38a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 8-bit signed value of the node.  <a href="#ga5bc29e58ae03edd0d764eac30b6ab38a">More...</a><br /></td></tr>
<tr class="separator:ga5bc29e58ae03edd0d764eac30b6ab38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcfbddcda8865d49667003bc16d41e42"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gadcfbddcda8865d49667003bc16d41e42">mpack_node_u16</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:gadcfbddcda8865d49667003bc16d41e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 16-bit unsigned value of the node.  <a href="#gadcfbddcda8865d49667003bc16d41e42">More...</a><br /></td></tr>
<tr class="separator:gadcfbddcda8865d49667003bc16d41e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe5d3aa7d76cb528a3dc10024a1eb0d9"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gafe5d3aa7d76cb528a3dc10024a1eb0d9">mpack_node_i16</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:gafe5d3aa7d76cb528a3dc10024a1eb0d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 16-bit signed value of the node.  <a href="#gafe5d3aa7d76cb528a3dc10024a1eb0d9">More...</a><br /></td></tr>
<tr class="separator:gafe5d3aa7d76cb528a3dc10024a1eb0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga996315bf57d89a2a6f5d4e2936ed74e4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga996315bf57d89a2a6f5d4e2936ed74e4">mpack_node_u32</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:ga996315bf57d89a2a6f5d4e2936ed74e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 32-bit unsigned value of the node.  <a href="#ga996315bf57d89a2a6f5d4e2936ed74e4">More...</a><br /></td></tr>
<tr class="separator:ga996315bf57d89a2a6f5d4e2936ed74e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0180b62e35f1438807cec5f1dc747f3d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga0180b62e35f1438807cec5f1dc747f3d">mpack_node_i32</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:ga0180b62e35f1438807cec5f1dc747f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 32-bit signed value of the node.  <a href="#ga0180b62e35f1438807cec5f1dc747f3d">More...</a><br /></td></tr>
<tr class="separator:ga0180b62e35f1438807cec5f1dc747f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d5e8f4732b9e7db24cf9f4581b13356"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga3d5e8f4732b9e7db24cf9f4581b13356">mpack_node_u64</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:ga3d5e8f4732b9e7db24cf9f4581b13356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 64-bit unsigned value of the node.  <a href="#ga3d5e8f4732b9e7db24cf9f4581b13356">More...</a><br /></td></tr>
<tr class="separator:ga3d5e8f4732b9e7db24cf9f4581b13356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1364528bea1667a421d39bad3e0453a"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gae1364528bea1667a421d39bad3e0453a">mpack_node_i64</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:gae1364528bea1667a421d39bad3e0453a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the 64-bit signed value of the node.  <a href="#gae1364528bea1667a421d39bad3e0453a">More...</a><br /></td></tr>
<tr class="separator:gae1364528bea1667a421d39bad3e0453a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28f422427efed19ce0a292b135a13067"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga28f422427efed19ce0a292b135a13067">mpack_node_uint</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:ga28f422427efed19ce0a292b135a13067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the unsigned int value of the node.  <a href="#ga28f422427efed19ce0a292b135a13067">More...</a><br /></td></tr>
<tr class="separator:ga28f422427efed19ce0a292b135a13067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7beb8942f1d779d6fd688a4db84a3358"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga7beb8942f1d779d6fd688a4db84a3358">mpack_node_int</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:ga7beb8942f1d779d6fd688a4db84a3358"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the int value of the node.  <a href="#ga7beb8942f1d779d6fd688a4db84a3358">More...</a><br /></td></tr>
<tr class="separator:ga7beb8942f1d779d6fd688a4db84a3358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66fed30759650f65e7edaef79b2c73f4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga66fed30759650f65e7edaef79b2c73f4">mpack_node_float</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:ga66fed30759650f65e7edaef79b2c73f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the float value of the node.  <a href="#ga66fed30759650f65e7edaef79b2c73f4">More...</a><br /></td></tr>
<tr class="separator:ga66fed30759650f65e7edaef79b2c73f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22bfc52e19de4f1b5f9db6a9373cce06"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga22bfc52e19de4f1b5f9db6a9373cce06">mpack_node_double</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:ga22bfc52e19de4f1b5f9db6a9373cce06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the double value of the node.  <a href="#ga22bfc52e19de4f1b5f9db6a9373cce06">More...</a><br /></td></tr>
<tr class="separator:ga22bfc52e19de4f1b5f9db6a9373cce06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b7dce2bf350091c232cf556ee50ace9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga2b7dce2bf350091c232cf556ee50ace9">mpack_node_float_strict</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:ga2b7dce2bf350091c232cf556ee50ace9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the float value of the node.  <a href="#ga2b7dce2bf350091c232cf556ee50ace9">More...</a><br /></td></tr>
<tr class="separator:ga2b7dce2bf350091c232cf556ee50ace9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74a690ab822846b19baa59f32cba766a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga74a690ab822846b19baa59f32cba766a">mpack_node_double_strict</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:ga74a690ab822846b19baa59f32cba766a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the double value of the node.  <a href="#ga74a690ab822846b19baa59f32cba766a">More...</a><br /></td></tr>
<tr class="separator:ga74a690ab822846b19baa59f32cba766a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Node String and Data Functions</h2></td></tr>
<tr class="memitem:gacb8292add714bdf140793a83469d8e9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gacb8292add714bdf140793a83469d8e9f">mpack_node_check_utf8</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:gacb8292add714bdf140793a83469d8e9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the given node contains a valid UTF-8 string.  <a href="#gacb8292add714bdf140793a83469d8e9f">More...</a><br /></td></tr>
<tr class="separator:gacb8292add714bdf140793a83469d8e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4dc121daf1202070c03fd56a5cd4fa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gaa4dc121daf1202070c03fd56a5cd4fa8">mpack_node_check_utf8_cstr</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:gaa4dc121daf1202070c03fd56a5cd4fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the given node contains a valid UTF-8 string with no NUL bytes.  <a href="#gaa4dc121daf1202070c03fd56a5cd4fa8">More...</a><br /></td></tr>
<tr class="separator:gaa4dc121daf1202070c03fd56a5cd4fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa7b359078cfddab88fc3c0c8fda4e295"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gaa7b359078cfddab88fc3c0c8fda4e295">mpack_node_exttype</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:gaa7b359078cfddab88fc3c0c8fda4e295"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the extension type of the given ext node.  <a href="#gaa7b359078cfddab88fc3c0c8fda4e295">More...</a><br /></td></tr>
<tr class="separator:gaa7b359078cfddab88fc3c0c8fda4e295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c44540f9af1a1a32dc260f6b787bb8c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga2c44540f9af1a1a32dc260f6b787bb8c">mpack_node_data_len</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:ga2c44540f9af1a1a32dc260f6b787bb8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the given str, bin or ext node.  <a href="#ga2c44540f9af1a1a32dc260f6b787bb8c">More...</a><br /></td></tr>
<tr class="separator:ga2c44540f9af1a1a32dc260f6b787bb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8a777b769930bea4e8a11738179ae7e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gae8a777b769930bea4e8a11738179ae7e">mpack_node_strlen</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:gae8a777b769930bea4e8a11738179ae7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length in bytes of the given string node.  <a href="#gae8a777b769930bea4e8a11738179ae7e">More...</a><br /></td></tr>
<tr class="separator:gae8a777b769930bea4e8a11738179ae7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9019bed33210791449cd9c594446fc8f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga9019bed33210791449cd9c594446fc8f">mpack_node_str</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:ga9019bed33210791449cd9c594446fc8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the data contained by this node, ensuring it is a string.  <a href="#ga9019bed33210791449cd9c594446fc8f">More...</a><br /></td></tr>
<tr class="separator:ga9019bed33210791449cd9c594446fc8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41ced2d8bfa19e4d19b0f18306bee140"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga41ced2d8bfa19e4d19b0f18306bee140">mpack_node_data</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:ga41ced2d8bfa19e4d19b0f18306bee140"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the data contained by this node.  <a href="#ga41ced2d8bfa19e4d19b0f18306bee140">More...</a><br /></td></tr>
<tr class="separator:ga41ced2d8bfa19e4d19b0f18306bee140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1133de49c7725d34512e096752be8f33"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga1133de49c7725d34512e096752be8f33">mpack_node_copy_data</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, char *buffer, size_t bufsize)</td></tr>
<tr class="memdesc:ga1133de49c7725d34512e096752be8f33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the bytes contained by this node into the given buffer, returning the number of bytes in the node.  <a href="#ga1133de49c7725d34512e096752be8f33">More...</a><br /></td></tr>
<tr class="separator:ga1133de49c7725d34512e096752be8f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c572f76b9b6870eaa765e3acb6954c1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga3c572f76b9b6870eaa765e3acb6954c1">mpack_node_copy_utf8</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, char *buffer, size_t bufsize)</td></tr>
<tr class="memdesc:ga3c572f76b9b6870eaa765e3acb6954c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the given node contains a valid UTF-8 string and copies the string into the given buffer, returning the number of bytes in the string.  <a href="#ga3c572f76b9b6870eaa765e3acb6954c1">More...</a><br /></td></tr>
<tr class="separator:ga3c572f76b9b6870eaa765e3acb6954c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf38c3d482a5eb473aa37594ee0ebf593"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gaf38c3d482a5eb473aa37594ee0ebf593">mpack_node_copy_cstr</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, char *buffer, size_t size)</td></tr>
<tr class="memdesc:gaf38c3d482a5eb473aa37594ee0ebf593"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the given node contains a string with no NUL bytes, copies the string into the given buffer, and adds a null terminator.  <a href="#gaf38c3d482a5eb473aa37594ee0ebf593">More...</a><br /></td></tr>
<tr class="separator:gaf38c3d482a5eb473aa37594ee0ebf593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf89e330244c3266c22bb8ce88f85dd66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gaf89e330244c3266c22bb8ce88f85dd66">mpack_node_copy_utf8_cstr</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, char *buffer, size_t size)</td></tr>
<tr class="memdesc:gaf89e330244c3266c22bb8ce88f85dd66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the given node contains a valid UTF-8 string with no NUL bytes, copies the string into the given buffer, and adds a null terminator.  <a href="#gaf89e330244c3266c22bb8ce88f85dd66">More...</a><br /></td></tr>
<tr class="separator:gaf89e330244c3266c22bb8ce88f85dd66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2799b6fabe286b3a7093c529e61739ef"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga2799b6fabe286b3a7093c529e61739ef">mpack_node_data_alloc</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, size_t maxsize)</td></tr>
<tr class="memdesc:ga2799b6fabe286b3a7093c529e61739ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new chunk of data using MPACK_MALLOC with the bytes contained by this node.  <a href="#ga2799b6fabe286b3a7093c529e61739ef">More...</a><br /></td></tr>
<tr class="separator:ga2799b6fabe286b3a7093c529e61739ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d7814632a852596f475994e0f388b99"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga6d7814632a852596f475994e0f388b99">mpack_node_cstr_alloc</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, size_t maxsize)</td></tr>
<tr class="memdesc:ga6d7814632a852596f475994e0f388b99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new null-terminated string using MPACK_MALLOC with the string contained by this node.  <a href="#ga6d7814632a852596f475994e0f388b99">More...</a><br /></td></tr>
<tr class="separator:ga6d7814632a852596f475994e0f388b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa52c0130b46f8e0c8efa9f38079ffd1c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gaa52c0130b46f8e0c8efa9f38079ffd1c">mpack_node_utf8_cstr_alloc</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, size_t maxsize)</td></tr>
<tr class="memdesc:gaa52c0130b46f8e0c8efa9f38079ffd1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates a new null-terminated string using MPACK_MALLOC with the UTF-8 string contained by this node.  <a href="#gaa52c0130b46f8e0c8efa9f38079ffd1c">More...</a><br /></td></tr>
<tr class="separator:gaa52c0130b46f8e0c8efa9f38079ffd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38538087fb67888dfb77682580fb5086"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga38538087fb67888dfb77682580fb5086">mpack_node_enum</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, const char *strings[], size_t count)</td></tr>
<tr class="memdesc:ga38538087fb67888dfb77682580fb5086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the given string array for a string matching the given node and returns its index.  <a href="#ga38538087fb67888dfb77682580fb5086">More...</a><br /></td></tr>
<tr class="separator:ga38538087fb67888dfb77682580fb5086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada6980d1ebe8433ee525d8919ab179b0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gada6980d1ebe8433ee525d8919ab179b0">mpack_node_enum_optional</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, const char *strings[], size_t count)</td></tr>
<tr class="memdesc:gada6980d1ebe8433ee525d8919ab179b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the given string array for a string matching the given node, returning its index or <em>count</em> if no strings match.  <a href="#gada6980d1ebe8433ee525d8919ab179b0">More...</a><br /></td></tr>
<tr class="separator:gada6980d1ebe8433ee525d8919ab179b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Compound Node Functions</h2></td></tr>
<tr class="memitem:ga831f47fdd6223dce326fe0f8ecc943d4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga831f47fdd6223dce326fe0f8ecc943d4">mpack_node_array_length</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:ga831f47fdd6223dce326fe0f8ecc943d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the given array node.  <a href="#ga831f47fdd6223dce326fe0f8ecc943d4">More...</a><br /></td></tr>
<tr class="separator:ga831f47fdd6223dce326fe0f8ecc943d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ec21fe2b75a99dc6c3ca5c6d7528c4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga9ec21fe2b75a99dc6c3ca5c6d7528c4e">mpack_node_array_at</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, size_t index)</td></tr>
<tr class="memdesc:ga9ec21fe2b75a99dc6c3ca5c6d7528c4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the node in the given array at the given index.  <a href="#ga9ec21fe2b75a99dc6c3ca5c6d7528c4e">More...</a><br /></td></tr>
<tr class="separator:ga9ec21fe2b75a99dc6c3ca5c6d7528c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03b7cb69d8648ede7a9d9d018b76b8a7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga03b7cb69d8648ede7a9d9d018b76b8a7">mpack_node_map_count</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="memdesc:ga03b7cb69d8648ede7a9d9d018b76b8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of key/value pairs in the given map node.  <a href="#ga03b7cb69d8648ede7a9d9d018b76b8a7">More...</a><br /></td></tr>
<tr class="separator:ga03b7cb69d8648ede7a9d9d018b76b8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadae87b62e9467e4aa0ad930cc58542af"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gadae87b62e9467e4aa0ad930cc58542af"></a>
<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_node_map_at</b> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, size_t index, size_t offset)</td></tr>
<tr class="separator:gadae87b62e9467e4aa0ad930cc58542af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74e16d4e1723a959ec90365078b9668c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga74e16d4e1723a959ec90365078b9668c">mpack_node_map_key_at</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, size_t index)</td></tr>
<tr class="memdesc:ga74e16d4e1723a959ec90365078b9668c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the key node in the given map at the given index.  <a href="#ga74e16d4e1723a959ec90365078b9668c">More...</a><br /></td></tr>
<tr class="separator:ga74e16d4e1723a959ec90365078b9668c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88b570192e47f589bc49cca2e88583b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga88b570192e47f589bc49cca2e88583b4">mpack_node_map_value_at</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, size_t index)</td></tr>
<tr class="memdesc:ga88b570192e47f589bc49cca2e88583b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value node in the given map at the given index.  <a href="#ga88b570192e47f589bc49cca2e88583b4">More...</a><br /></td></tr>
<tr class="separator:ga88b570192e47f589bc49cca2e88583b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad85dcc667be1797e106fc106346ee828"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gad85dcc667be1797e106fc106346ee828">mpack_node_map_int</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, int64_t num)</td></tr>
<tr class="memdesc:gad85dcc667be1797e106fc106346ee828"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value node in the given map for the given integer key.  <a href="#gad85dcc667be1797e106fc106346ee828">More...</a><br /></td></tr>
<tr class="separator:gad85dcc667be1797e106fc106346ee828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga107c576a3abc79e7dd0048e8ecdbcffc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga107c576a3abc79e7dd0048e8ecdbcffc">mpack_node_map_int_optional</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, int64_t num)</td></tr>
<tr class="memdesc:ga107c576a3abc79e7dd0048e8ecdbcffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value node in the given map for the given integer key, or a nil node if the map does not contain the given key.  <a href="#ga107c576a3abc79e7dd0048e8ecdbcffc">More...</a><br /></td></tr>
<tr class="separator:ga107c576a3abc79e7dd0048e8ecdbcffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1b0edee199d7a2ed032efe412328a29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gab1b0edee199d7a2ed032efe412328a29">mpack_node_map_uint</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, uint64_t num)</td></tr>
<tr class="memdesc:gab1b0edee199d7a2ed032efe412328a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value node in the given map for the given unsigned integer key.  <a href="#gab1b0edee199d7a2ed032efe412328a29">More...</a><br /></td></tr>
<tr class="separator:gab1b0edee199d7a2ed032efe412328a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab11b76ad94a8b758203b3c530af88112"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gab11b76ad94a8b758203b3c530af88112">mpack_node_map_uint_optional</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, uint64_t num)</td></tr>
<tr class="memdesc:gab11b76ad94a8b758203b3c530af88112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value node in the given map for the given unsigned integer key, or a nil node if the map does not contain the given key.  <a href="#gab11b76ad94a8b758203b3c530af88112">More...</a><br /></td></tr>
<tr class="separator:gab11b76ad94a8b758203b3c530af88112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae307e6001afd0af57b76e612ec74c1b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gae307e6001afd0af57b76e612ec74c1b3">mpack_node_map_str</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, const char *str, size_t length)</td></tr>
<tr class="memdesc:gae307e6001afd0af57b76e612ec74c1b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value node in the given map for the given string key.  <a href="#gae307e6001afd0af57b76e612ec74c1b3">More...</a><br /></td></tr>
<tr class="separator:gae307e6001afd0af57b76e612ec74c1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6adb4420a9f506885e65bb54f35909ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga6adb4420a9f506885e65bb54f35909ce">mpack_node_map_str_optional</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, const char *str, size_t length)</td></tr>
<tr class="memdesc:ga6adb4420a9f506885e65bb54f35909ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value node in the given map for the given string key, or a nil node if the map does not contain the given key.  <a href="#ga6adb4420a9f506885e65bb54f35909ce">More...</a><br /></td></tr>
<tr class="separator:ga6adb4420a9f506885e65bb54f35909ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ce515ec366036b1602bafe65a56ef7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga6ce515ec366036b1602bafe65a56ef7e">mpack_node_map_cstr</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, const char *cstr)</td></tr>
<tr class="memdesc:ga6ce515ec366036b1602bafe65a56ef7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value node in the given map for the given null-terminated string key.  <a href="#ga6ce515ec366036b1602bafe65a56ef7e">More...</a><br /></td></tr>
<tr class="separator:ga6ce515ec366036b1602bafe65a56ef7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga349940b9a92f53b8dbdfdab049cc667e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga349940b9a92f53b8dbdfdab049cc667e">mpack_node_map_cstr_optional</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, const char *cstr)</td></tr>
<tr class="memdesc:ga349940b9a92f53b8dbdfdab049cc667e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value node in the given map for the given null-terminated string key, or a nil node if the map does not contain the given key.  <a href="#ga349940b9a92f53b8dbdfdab049cc667e">More...</a><br /></td></tr>
<tr class="separator:ga349940b9a92f53b8dbdfdab049cc667e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8682cff06a6b350f392d6e9ceaf6d9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gaf8682cff06a6b350f392d6e9ceaf6d9b">mpack_node_map_contains_int</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, int64_t num)</td></tr>
<tr class="memdesc:gaf8682cff06a6b350f392d6e9ceaf6d9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node map contains exactly one entry with the given integer key.  <a href="#gaf8682cff06a6b350f392d6e9ceaf6d9b">More...</a><br /></td></tr>
<tr class="separator:gaf8682cff06a6b350f392d6e9ceaf6d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ab9e368bbde89763962102bff9933b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga9ab9e368bbde89763962102bff9933b2">mpack_node_map_contains_uint</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, uint64_t num)</td></tr>
<tr class="memdesc:ga9ab9e368bbde89763962102bff9933b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node map contains exactly one entry with the given unsigned integer key.  <a href="#ga9ab9e368bbde89763962102bff9933b2">More...</a><br /></td></tr>
<tr class="separator:ga9ab9e368bbde89763962102bff9933b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5da5d0fcfeae4bc1edb7904fd230f783"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga5da5d0fcfeae4bc1edb7904fd230f783">mpack_node_map_contains_str</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, const char *str, size_t length)</td></tr>
<tr class="memdesc:ga5da5d0fcfeae4bc1edb7904fd230f783"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node map contains exactly one entry with the given string key.  <a href="#ga5da5d0fcfeae4bc1edb7904fd230f783">More...</a><br /></td></tr>
<tr class="separator:ga5da5d0fcfeae4bc1edb7904fd230f783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1be7c8845cff656408450ca31c3c3cad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga1be7c8845cff656408450ca31c3c3cad">mpack_node_map_contains_cstr</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, const char *cstr)</td></tr>
<tr class="memdesc:ga1be7c8845cff656408450ca31c3c3cad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given node map contains exactly one entry with the given null-terminated string key.  <a href="#ga1be7c8845cff656408450ca31c3c3cad">More...</a><br /></td></tr>
<tr class="separator:ga1be7c8845cff656408450ca31c3c3cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga37218aec593259aed8b28625ff1395fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__node.html#ga37218aec593259aed8b28625ff1395fb">mpack_node_data_t</a> <a class="el" href="group__node.html#ga37218aec593259aed8b28625ff1395fb">mpack_node_data_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The storage for nodes in an MPack tree. </p>
<p>You only need to use this if you intend to provide your own storage for nodes instead of letting the tree allocate it. </p>

</div>
</div>
<a class="anchor" id="ga08f46371c0c59a2e4dd7bdf1891fb3cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> <a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A handle to node data in a parsed MPack tree. </p>
<p>Nodes represent either primitive values or compound types. If a node is a compound type, it contains a pointer to its child nodes, or a pointer to its underlying data.</p>
<p>Nodes are immutable.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> is a handle, not the node data itself. It is passed by value in the Node API. </dd></dl>

</div>
</div>
<a class="anchor" id="ga184ff3fbec66290ec72caf0abc8f3594"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* mpack_tree_error_t) (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An error handler function to be called when an error is flagged on the tree. </p>
<p>The error handler will only be called once on the first error flagged; any subsequent node reads and errors are ignored, and the tree is permanently in that error state.</p>
<p>MPack is safe against non-local jumps out of error handler callbacks. This means you are allowed to longjmp or throw an exception (in C++, Objective-C, or with SEH) out of this callback.</p>
<p>Bear in mind when using longjmp that local non-volatile variables that have changed are undefined when setjmp() returns, so you can't put the tree on the stack in the same activation frame as the setjmp without declaring it volatile.</p>
<p>You must still eventually destroy the tree. It is not destroyed automatically when an error is flagged. It is safe to destroy the tree within this error callback, but you will either need to perform a non-local jump, or store something in your context to identify that the tree is destroyed since any future accesses to it cause undefined behavior. </p>

</div>
</div>
<a class="anchor" id="ga9c76cfdb08042d6412b5c745bca928a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> <a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An MPack tree parsed from a blob of MessagePack. </p>
<p>The tree contains a single root node which contains all parsed data. The tree and its nodes are immutable. </p>

</div>
</div>
<a class="anchor" id="ga1ca1eb6735624e7d98d64ac77b525c55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* mpack_tree_teardown_t) (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A teardown function to be called when the tree is destroyed. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga9ec21fe2b75a99dc6c3ca5c6d7528c4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_array_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the node in the given array at the given index. </p>
<p>If the node is not an array, mpack_error_type is raised and a nil node is returned. If the given index is out of bounds, mpack_error_data is raised and a nil node is returned. </p>

</div>
</div>
<a class="anchor" id="ga831f47fdd6223dce326fe0f8ecc943d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_node_array_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of the given array node. </p>
<p>Raises mpack_error_type and returns 0 if the given node is not an array. </p>

</div>
</div>
<a class="anchor" id="gad15f3dba3fe1c0b5b7d9ed5d2c34215a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_node_bool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the bool value of the node. </p>
<p>If this node is not of the correct type, false is returned and mpack_error_type is raised. </p>

</div>
</div>
<a class="anchor" id="gacb8292add714bdf140793a83469d8e9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_node_check_utf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that the given node contains a valid UTF-8 string. </p>
<p>If the string is invalid, this flags an error, which would cause subsequent calls to <a class="el" href="group__node.html#ga9019bed33210791449cd9c594446fc8f" title="Returns a pointer to the data contained by this node, ensuring it is a string. ">mpack_node_str()</a> to return NULL and <a class="el" href="group__node.html#gae8a777b769930bea4e8a11738179ae7e" title="Returns the length in bytes of the given string node. ">mpack_node_strlen()</a> to return zero. So you can check the node for error immediately after calling this, or you can call those functions to use the data anyway and check for errors later.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If this node is not a string or does not contain valid UTF-8.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The string node to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__node.html#ga9019bed33210791449cd9c594446fc8f" title="Returns a pointer to the data contained by this node, ensuring it is a string. ">mpack_node_str()</a> </dd>
<dd>
<a class="el" href="group__node.html#gae8a777b769930bea4e8a11738179ae7e" title="Returns the length in bytes of the given string node. ">mpack_node_strlen()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4dc121daf1202070c03fd56a5cd4fa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_node_check_utf8_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that the given node contains a valid UTF-8 string with no NUL bytes. </p>
<p>This does not check that the string has a null-terminator! It only checks whether the string could safely be represented as a C-string by appending a null-terminator. (If the string does already contain a null-terminator, this will flag an error.)</p>
<p>This is performed automatically by other UTF-8 cstr helper functions. Only call this if you will do something else with the data directly, but you still want to ensure it will be valid as a UTF-8 C-string.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If this node is not a string, does not contain valid UTF-8, or contains a NUL byte.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The string node to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__node.html#ga9019bed33210791449cd9c594446fc8f" title="Returns a pointer to the data contained by this node, ensuring it is a string. ">mpack_node_str()</a> </dd>
<dd>
<a class="el" href="group__node.html#gae8a777b769930bea4e8a11738179ae7e" title="Returns the length in bytes of the given string node. ">mpack_node_strlen()</a> </dd>
<dd>
<a class="el" href="group__node.html#gaf89e330244c3266c22bb8ce88f85dd66" title="Checks that the given node contains a valid UTF-8 string with no NUL bytes, copies the string into th...">mpack_node_copy_utf8_cstr()</a> </dd>
<dd>
<a class="el" href="group__node.html#gaa52c0130b46f8e0c8efa9f38079ffd1c" title="Allocates a new null-terminated string using MPACK_MALLOC with the UTF-8 string contained by this nod...">mpack_node_utf8_cstr_alloc()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaf38c3d482a5eb473aa37594ee0ebf593"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_node_copy_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that the given node contains a string with no NUL bytes, copies the string into the given buffer, and adds a null terminator. </p>
<p>If this node is not of a string type, mpack_error_type is raised. If the string does not fit, mpack_error_data is raised.</p>
<p>If any error occurs, the buffer will contain an empty null-terminated string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The string node from which to copy data </td></tr>
    <tr><td class="paramname">buffer</td><td>A buffer in which to copy the node's string </td></tr>
    <tr><td class="paramname">size</td><td>The size of the given buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1133de49c7725d34512e096752be8f33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_node_copy_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copies the bytes contained by this node into the given buffer, returning the number of bytes in the node. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If this node is not a str, bin or ext type </td></tr>
    <tr><td class="paramname">mpack_error_too_big</td><td>If the string does not fit in the given buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The string node from which to copy data </td></tr>
    <tr><td class="paramname">buffer</td><td>A buffer in which to copy the node's bytes </td></tr>
    <tr><td class="paramname">bufsize</td><td>The size of the given buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the node, or zero if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3c572f76b9b6870eaa765e3acb6954c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_node_copy_utf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that the given node contains a valid UTF-8 string and copies the string into the given buffer, returning the number of bytes in the string. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If this node is not a string </td></tr>
    <tr><td class="paramname">mpack_error_too_big</td><td>If the string does not fit in the given buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The string node from which to copy data </td></tr>
    <tr><td class="paramname">buffer</td><td>A buffer in which to copy the node's bytes </td></tr>
    <tr><td class="paramname">bufsize</td><td>The size of the given buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the node, or zero if an error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf89e330244c3266c22bb8ce88f85dd66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_node_copy_utf8_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that the given node contains a valid UTF-8 string with no NUL bytes, copies the string into the given buffer, and adds a null terminator. </p>
<p>If this node is not of a string type, mpack_error_type is raised. If the string does not fit, mpack_error_data is raised.</p>
<p>If any error occurs, the buffer will contain an empty null-terminated string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The string node from which to copy data </td></tr>
    <tr><td class="paramname">buffer</td><td>A buffer in which to copy the node's string </td></tr>
    <tr><td class="paramname">size</td><td>The size of the given buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6d7814632a852596f475994e0f388b99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_node_cstr_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new null-terminated string using MPACK_MALLOC with the string contained by this node. </p>
<p>The allocated string must be freed with <a class="el" href="group__config.html#ga298d7c2e4093bcfe361088df9e35956a" title="Defines the memory free function used by MPack. ">MPACK_FREE()</a> (or simply free() if MPack's allocator hasn't been customized.)</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If this node is not a string or contains NUL bytes </td></tr>
    <tr><td class="paramname">mpack_error_too_big</td><td>If the size of the string plus null-terminator is larger than the given maximum size </td></tr>
    <tr><td class="paramname">mpack_error_memory</td><td>If an allocation failure occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node from which to allocate and copy string data </td></tr>
    <tr><td class="paramname">maxsize</td><td>The maximum size to allocate, including the null-terminator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated string, or NULL if any error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="ga41ced2d8bfa19e4d19b0f18306bee140"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* mpack_node_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the data contained by this node. </p>
<dl class="section note"><dt>Note</dt><dd>Strings are not null-terminated! Use one of the cstr functions to get a null-terminated string.</dd></dl>
<p>The pointer is valid as long as the data backing the tree is valid.</p>
<p>If this node is not of a str, bin or map, mpack_error_type is raised, and <code>NULL</code> is returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__node.html#gaf38c3d482a5eb473aa37594ee0ebf593" title="Checks that the given node contains a string with no NUL bytes, copies the string into the given buff...">mpack_node_copy_cstr()</a> </dd>
<dd>
<a class="el" href="group__node.html#ga6d7814632a852596f475994e0f388b99" title="Allocates a new null-terminated string using MPACK_MALLOC with the string contained by this node...">mpack_node_cstr_alloc()</a> </dd>
<dd>
<a class="el" href="group__node.html#gaa52c0130b46f8e0c8efa9f38079ffd1c" title="Allocates a new null-terminated string using MPACK_MALLOC with the UTF-8 string contained by this nod...">mpack_node_utf8_cstr_alloc()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga2799b6fabe286b3a7093c529e61739ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_node_data_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new chunk of data using MPACK_MALLOC with the bytes contained by this node. </p>
<p>The allocated data must be freed with <a class="el" href="group__config.html#ga298d7c2e4093bcfe361088df9e35956a" title="Defines the memory free function used by MPack. ">MPACK_FREE()</a> (or simply free() if MPack's allocator hasn't been customized.)</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If this node is not a str, bin or ext type </td></tr>
    <tr><td class="paramname">mpack_error_too_big</td><td>If the size of the data is larger than the given maximum size </td></tr>
    <tr><td class="paramname">mpack_error_memory</td><td>If an allocation failure occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node from which to allocate and copy data </td></tr>
    <tr><td class="paramname">maxsize</td><td>The maximum size to allocate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated data, or NULL if any error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2c44540f9af1a1a32dc260f6b787bb8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_node_data_len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length of the given str, bin or ext node. </p>
<p>This returns zero if the tree is in an error state. </p>

</div>
</div>
<a class="anchor" id="ga22bfc52e19de4f1b5f9db6a9373cce06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mpack_node_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the double value of the node. </p>
<p>The underlying value can be an integer, float or double; the value is converted to a double.</p>
<dl class="section note"><dt>Note</dt><dd>Reading a very large integer with this function can incur a loss of precision.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float, double or integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga74a690ab822846b19baa59f32cba766a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mpack_node_double_strict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the double value of the node. </p>
<p>The underlying value must be a float or double, not an integer. This ensures no loss of precision can occur.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float or double. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga38538087fb67888dfb77682580fb5086"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_node_enum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>strings</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches the given string array for a string matching the given node and returns its index. </p>
<p>If the node does not match any of the given strings, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is flagged. Use <a class="el" href="group__node.html#gada6980d1ebe8433ee525d8919ab179b0" title="Searches the given string array for a string matching the given node, returning its index or count if...">mpack_node_enum_optional()</a> if you want to allow values other than the given strings.</p>
<p>If any error occurs or if the tree is in an error state, <em>count</em> is returned.</p>
<p>This can be used to quickly parse a string into an enum when the enum values range from 0 to <em>count-1</em>. If the last value in the enum is a special "count" value, it can be passed as the count, and the return value can be cast directly to the enum type.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>           { APPLE ,  BANANA ,  ORANGE , COUNT} fruit_t;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* fruits[] = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>};</div><div class="line"></div><div class="line">fruit_t fruit = (fruit_t)<a class="code" href="group__node.html#ga38538087fb67888dfb77682580fb5086">mpack_node_enum</a>(node, fruits, COUNT);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node </td></tr>
    <tr><td class="paramname">strings</td><td>An array of expected strings of length count </td></tr>
    <tr><td class="paramname">count</td><td>The number of strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the matched string, or <em>count</em> in case of error </dd></dl>

</div>
</div>
<a class="anchor" id="gada6980d1ebe8433ee525d8919ab179b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_node_enum_optional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>strings</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Searches the given string array for a string matching the given node, returning its index or <em>count</em> if no strings match. </p>
<p>If the value is not a string, or it does not match any of the given strings, <em>count</em> is returned and no error is flagged.</p>
<p>If any error occurs or if the tree is in an error state, <em>count</em> is returned.</p>
<p>This can be used to quickly parse a string into an enum when the enum values range from 0 to <em>count-1</em>. If the last value in the enum is a special "count" value, it can be passed as the count, and the return value can be cast directly to the enum type.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>           { APPLE ,  BANANA ,  ORANGE , COUNT} fruit_t;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* fruits[] = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>};</div><div class="line"></div><div class="line">fruit_t fruit = (fruit_t)<a class="code" href="group__node.html#gada6980d1ebe8433ee525d8919ab179b0">mpack_node_enum_optional</a>(node, fruits, COUNT);</div></div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node </td></tr>
    <tr><td class="paramname">strings</td><td>An array of expected strings of length count </td></tr>
    <tr><td class="paramname">count</td><td>The number of strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the matched string, or <em>count</em> in case of error </dd></dl>

</div>
</div>
<a class="anchor" id="ga50003b22aceb00adfa11cd382a9eb7e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> mpack_node_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the error state of the node's tree. </p>

</div>
</div>
<a class="anchor" id="gaa7b359078cfddab88fc3c0c8fda4e295"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t mpack_node_exttype </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the extension type of the given ext node. </p>
<p>This returns zero if the tree is in an error state. </p>

</div>
</div>
<a class="anchor" id="gabc37f432559b3b4be52e91e66a09f57d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_node_false </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given node is of bool type with value false, raising mpack_error_type otherwise. </p>

</div>
</div>
<a class="anchor" id="ga46d2b3688954e32cb81268f982362036"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_node_flag_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places the node's tree in the given error state, calling the error callback if one is set. </p>
<p>This allows you to externally flag errors, for example if you are validating data as you read it.</p>
<p>If the tree is already in an error state, this call is ignored and no error callback is called. </p>

</div>
</div>
<a class="anchor" id="ga66fed30759650f65e7edaef79b2c73f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float mpack_node_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the float value of the node. </p>
<p>The underlying value can be an integer, float or double; the value is converted to a float.</p>
<dl class="section note"><dt>Note</dt><dd>Reading a double or a large integer with this function can incur a loss of precision.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float, double or integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2b7dce2bf350091c232cf556ee50ace9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float mpack_node_float_strict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the float value of the node. </p>
<p>The underlying value must be a float, not a double or an integer. This ensures no loss of precision can occur.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gafe5d3aa7d76cb528a3dc10024a1eb0d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t mpack_node_i16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 16-bit signed value of the node. </p>
<p>If this node is not of a compatible type, mpack_error_type is raised and zero is returned. </p>

</div>
</div>
<a class="anchor" id="ga0180b62e35f1438807cec5f1dc747f3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mpack_node_i32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 32-bit signed value of the node. </p>
<p>If this node is not of a compatible type, mpack_error_type is raised and zero is returned. </p>

</div>
</div>
<a class="anchor" id="gae1364528bea1667a421d39bad3e0453a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpack_node_i64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 64-bit signed value of the node. </p>
<p>If this node is not of a compatible type, mpack_error_type is raised and zero is returned. </p>

</div>
</div>
<a class="anchor" id="ga5bc29e58ae03edd0d764eac30b6ab38a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t mpack_node_i8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 8-bit signed value of the node. </p>
<p>If this node is not of a compatible type, mpack_error_type is raised and zero is returned. </p>

</div>
</div>
<a class="anchor" id="ga7beb8942f1d779d6fd688a4db84a3358"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpack_node_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the int value of the node. </p>
<p>Returns zero if an error occurs.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not an integer type or does not fit in the range of an int </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1be7c8845cff656408450ca31c3c3cad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_node_map_contains_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node map contains exactly one entry with the given null-terminated string key. </p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node contains more than one entry with the given key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf8682cff06a6b350f392d6e9ceaf6d9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_node_map_contains_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node map contains exactly one entry with the given integer key. </p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node contains more than one entry with the given key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5da5d0fcfeae4bc1edb7904fd230f783"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_node_map_contains_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node map contains exactly one entry with the given string key. </p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node contains more than one entry with the given key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9ab9e368bbde89763962102bff9933b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_node_map_contains_uint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the given node map contains exactly one entry with the given unsigned integer key. </p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node contains more than one entry with the given key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga03b7cb69d8648ede7a9d9d018b76b8a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_node_map_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of key/value pairs in the given map node. </p>
<p>Raises mpack_error_type and returns 0 if the given node is not a map. </p>

</div>
</div>
<a class="anchor" id="ga6ce515ec366036b1602bafe65a56ef7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_map_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value node in the given map for the given null-terminated string key. </p>
<p>The key must exist within the map. Use <a class="el" href="group__node.html#ga349940b9a92f53b8dbdfdab049cc667e" title="Returns the value node in the given map for the given null-terminated string key, or a nil node if th...">mpack_node_map_cstr_optional()</a> to check for optional keys.</p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node does not contain exactly one entry with the given key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value node for the given key, or a nil node in case of error </dd></dl>

</div>
</div>
<a class="anchor" id="ga349940b9a92f53b8dbdfdab049cc667e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_map_cstr_optional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value node in the given map for the given null-terminated string key, or a nil node if the map does not contain the given key. </p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node contains more than one entry with the given key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value node for the given key, or a nil node in case of error </dd></dl>

</div>
</div>
<a class="anchor" id="gad85dcc667be1797e106fc106346ee828"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_map_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value node in the given map for the given integer key. </p>
<p>The key must exist within the map. Use <a class="el" href="group__node.html#ga107c576a3abc79e7dd0048e8ecdbcffc" title="Returns the value node in the given map for the given integer key, or a nil node if the map does not ...">mpack_node_map_int_optional()</a> to check for optional keys.</p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node does not contain exactly one entry with the given key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value node for the given key, or a nil node in case of error </dd></dl>

</div>
</div>
<a class="anchor" id="ga107c576a3abc79e7dd0048e8ecdbcffc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_map_int_optional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value node in the given map for the given integer key, or a nil node if the map does not contain the given key. </p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node contains more than one entry with the given key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value node for the given key, or a nil node in case of error </dd></dl>

</div>
</div>
<a class="anchor" id="ga74e16d4e1723a959ec90365078b9668c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_map_key_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the key node in the given map at the given index. </p>
<p>A nil node is returned in case of error.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>if the given index is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gae307e6001afd0af57b76e612ec74c1b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_map_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value node in the given map for the given string key. </p>
<p>The key must exist within the map. Use <a class="el" href="group__node.html#ga6adb4420a9f506885e65bb54f35909ce" title="Returns the value node in the given map for the given string key, or a nil node if the map does not c...">mpack_node_map_str_optional()</a> to check for optional keys.</p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node does not contain exactly one entry with the given key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value node for the given key, or a nil node in case of error </dd></dl>

</div>
</div>
<a class="anchor" id="ga6adb4420a9f506885e65bb54f35909ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_map_str_optional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value node in the given map for the given string key, or a nil node if the map does not contain the given key. </p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node contains more than one entry with the given key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value node for the given key, or a nil node in case of error </dd></dl>

</div>
</div>
<a class="anchor" id="gab1b0edee199d7a2ed032efe412328a29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_map_uint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value node in the given map for the given unsigned integer key. </p>
<p>The key must exist within the map. Use <a class="el" href="group__node.html#gab11b76ad94a8b758203b3c530af88112" title="Returns the value node in the given map for the given unsigned integer key, or a nil node if the map ...">mpack_node_map_uint_optional()</a> to check for optional keys.</p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node does not contain exactly one entry with the given key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value node for the given key, or a nil node in case of error </dd></dl>

</div>
</div>
<a class="anchor" id="gab11b76ad94a8b758203b3c530af88112"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_map_uint_optional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value node in the given map for the given unsigned integer key, or a nil node if the map does not contain the given key. </p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node contains more than one entry with the given key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value node for the given key, or a nil node in case of error </dd></dl>

</div>
</div>
<a class="anchor" id="ga88b570192e47f589bc49cca2e88583b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_map_value_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value node in the given map at the given index. </p>
<p>A nil node is returned in case of error.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>if the given index is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga42f4b9aebd9d612b1e5073490a4abba4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_node_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given node is of nil type, raising mpack_error_type otherwise. </p>

</div>
</div>
<a class="anchor" id="gad244551de13bd2574fb0fe7da6ba5fdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_node_print </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a node to pseudo-JSON for debugging purposes and pretty-prints it to stdout. </p>

</div>
</div>
<a class="anchor" id="gaa405ce9d3f8739ee56fe6ca50a169543"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_node_print_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>file</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a node to pseudo-JSON for debugging purposes and pretty-prints it to the given file. </p>

</div>
</div>
<a class="anchor" id="ga9019bed33210791449cd9c594446fc8f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* mpack_node_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a pointer to the data contained by this node, ensuring it is a string. </p>
<dl class="section note"><dt>Note</dt><dd>Strings are not null-terminated! Use one of the cstr functions to get a null-terminated string.</dd></dl>
<p>The pointer is valid as long as the data backing the tree is valid.</p>
<p>If this node is not a string, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised and <code>NULL</code> is returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__node.html#gaf38c3d482a5eb473aa37594ee0ebf593" title="Checks that the given node contains a string with no NUL bytes, copies the string into the given buff...">mpack_node_copy_cstr()</a> </dd>
<dd>
<a class="el" href="group__node.html#ga6d7814632a852596f475994e0f388b99" title="Allocates a new null-terminated string using MPACK_MALLOC with the string contained by this node...">mpack_node_cstr_alloc()</a> </dd>
<dd>
<a class="el" href="group__node.html#gaa52c0130b46f8e0c8efa9f38079ffd1c" title="Allocates a new null-terminated string using MPACK_MALLOC with the UTF-8 string contained by this nod...">mpack_node_utf8_cstr_alloc()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gae8a777b769930bea4e8a11738179ae7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_node_strlen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the length in bytes of the given string node. </p>
<p>This does not include any null-terminator.</p>
<p>This returns zero if the tree is in an error state. </p>

</div>
</div>
<a class="anchor" id="ga9bafb2aa97ea8ce8f517303329236b2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common.html#structmpack__tag__t">mpack_tag_t</a> mpack_node_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a tag describing the given node, or a nil tag if the tree is in an error state. </p>

</div>
</div>
<a class="anchor" id="gab54c26f5fc03f73b02070a72610c9127"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_node_true </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given node is of bool type with value true, raising mpack_error_type otherwise. </p>

</div>
</div>
<a class="anchor" id="gabf769643817c3d88f98cc40801fba2eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common.html#ga22f03cf1240d5a917e1b3e7be8ab327e">mpack_type_t</a> mpack_node_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the type of the node. </p>

</div>
</div>
<a class="anchor" id="gadcfbddcda8865d49667003bc16d41e42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t mpack_node_u16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 16-bit unsigned value of the node. </p>
<p>If this node is not of a compatible type, mpack_error_type is raised and zero is returned. </p>

</div>
</div>
<a class="anchor" id="ga996315bf57d89a2a6f5d4e2936ed74e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_node_u32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 32-bit unsigned value of the node. </p>
<p>If this node is not of a compatible type, mpack_error_type is raised and zero is returned. </p>

</div>
</div>
<a class="anchor" id="ga3d5e8f4732b9e7db24cf9f4581b13356"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mpack_node_u64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 64-bit unsigned value of the node. </p>
<p>If this node is not of a compatible type, mpack_error_type is raised, and zero is returned. </p>

</div>
</div>
<a class="anchor" id="gad54f9c1d4bfdb0ae572782c4307d475f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t mpack_node_u8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the 8-bit unsigned value of the node. </p>
<p>If this node is not of a compatible type, mpack_error_type is raised and zero is returned. </p>

</div>
</div>
<a class="anchor" id="ga28f422427efed19ce0a292b135a13067"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mpack_node_uint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the unsigned int value of the node. </p>
<p>Returns zero if an error occurs.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not an integer type or does not fit in the range of an unsigned int </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa52c0130b46f8e0c8efa9f38079ffd1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_node_utf8_cstr_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates a new null-terminated string using MPACK_MALLOC with the UTF-8 string contained by this node. </p>
<p>The allocated string must be freed with <a class="el" href="group__config.html#ga298d7c2e4093bcfe361088df9e35956a" title="Defines the memory free function used by MPack. ">MPACK_FREE()</a> (or simply free() if MPack's allocator hasn't been customized.)</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If this node is not a string, is not valid UTF-8, or contains NUL bytes </td></tr>
    <tr><td class="paramname">mpack_error_too_big</td><td>If the size of the string plus null-terminator is larger than the given maximum size </td></tr>
    <tr><td class="paramname">mpack_error_memory</td><td>If an allocation failure occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node from which to allocate and copy string data </td></tr>
    <tr><td class="paramname">maxsize</td><td>The maximum size to allocate, including the null-terminator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated string, or NULL if any error occurs. </dd></dl>

</div>
</div>
<a class="anchor" id="gabf57acbc8356be8fab13a64f78986fdc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> mpack_tree_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the tree. </p>

</div>
</div>
<a class="anchor" id="gac62f4d7bfac176dd636924f201cc4712"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> mpack_tree_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the error state of the tree. </p>

</div>
</div>
<a class="anchor" id="ga46fdd2e384e7399f07a600e13962a492"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_tree_flag_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Places the tree in the given error state, calling the error callback if one is set. </p>
<p>This allows you to externally flag errors, for example if you are validating data as you read it.</p>
<p>If the tree is already in an error state, this call is ignored and no error callback is called. </p>

</div>
</div>
<a class="anchor" id="ga57182f50afa56ca6a912620e894ed7c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_tree_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a tree by parsing the given data buffer. </p>
<p>The tree must be destroyed with <a class="el" href="group__node.html#gabf57acbc8356be8fab13a64f78986fdc" title="Destroys the tree. ">mpack_tree_destroy()</a>, even if parsing fails.</p>
<p>The tree will allocate pages of nodes as needed, and free them when destroyed.</p>
<p>Any string or blob data types reference the original data, so the data pointer must remain valid until after the tree is destroyed. </p>

</div>
</div>
<a class="anchor" id="gad8360ae0ff58c0b6fb5c5997297b602c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_tree_init_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes an MPack tree directly into an error state. </p>
<p>Use this if you are writing a wrapper to <a class="el" href="group__node.html#ga57182f50afa56ca6a912620e894ed7c3" title="Initializes a tree by parsing the given data buffer. ">mpack_tree_init()</a> which can fail its setup. </p>

</div>
</div>
<a class="anchor" id="ga2f8327cf4ebc79d9358ee0a1643af66c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_tree_init_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a tree by reading and parsing the given file. </p>
<p>The tree must be destroyed with <a class="el" href="group__node.html#gabf57acbc8356be8fab13a64f78986fdc" title="Destroys the tree. ">mpack_tree_destroy()</a>, even if parsing fails.</p>
<p>The file is opened, loaded fully into memory, and closed before this call returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The tree to initialize </td></tr>
    <tr><td class="paramname">filename</td><td>The filename passed to fopen() to read the file </td></tr>
    <tr><td class="paramname">max_bytes</td><td>The maximum size of file to load, or 0 for unlimited size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3cb51d3adfadc336a2ac28605a939a83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_tree_init_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__node.html#ga37218aec593259aed8b28625ff1395fb">mpack_node_data_t</a> *&#160;</td>
          <td class="paramname"><em>node_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node_pool_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a tree by parsing the given data buffer, using the given node data pool to store the results. </p>
<p>If the data does not fit in the pool, mpack_error_too_big will be flagged on the tree.</p>
<p>The tree must be destroyed with <a class="el" href="group__node.html#gabf57acbc8356be8fab13a64f78986fdc" title="Destroys the tree. ">mpack_tree_destroy()</a>, even if parsing fails. </p>

</div>
</div>
<a class="anchor" id="ga2c49262ce28699d5ec90db09b5fd2eee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_tree_root </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the root node of the tree, if the tree is not in an error state. </p>
<p>Returns a nil node otherwise. </p>

</div>
</div>
<a class="anchor" id="gaad3dea301d544aa434ca661ef3b913d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_tree_set_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the custom pointer to pass to the tree callbacks, such as teardown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The MPack tree. </td></tr>
    <tr><td class="paramname">context</td><td>User data to pass to the tree callbacks. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga9dcb3d1c5b6d0f00223ff2a7b7fb36f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_tree_set_error_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__node.html#ga184ff3fbec66290ec72caf0abc8f3594">mpack_tree_error_t</a>&#160;</td>
          <td class="paramname"><em>error_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the error function to call when an error is flagged on the tree. </p>
<p>This should normally be used with <a class="el" href="group__node.html#gaad3dea301d544aa434ca661ef3b913d1" title="Sets the custom pointer to pass to the tree callbacks, such as teardown. ">mpack_tree_set_context()</a> to register a custom pointer to pass to the error function.</p>
<p>See the definition of mpack_tree_error_t for more information about what you can do from an error callback.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__node.html#ga184ff3fbec66290ec72caf0abc8f3594" title="An error handler function to be called when an error is flagged on the tree. ">mpack_tree_error_t</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The MPack tree. </td></tr>
    <tr><td class="paramname">error_fn</td><td>The function to call when an error is flagged on the tree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabfbf5d62990974e24f8abfed38c554e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_tree_set_teardown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__node.html#ga1ca1eb6735624e7d98d64ac77b525c55">mpack_tree_teardown_t</a>&#160;</td>
          <td class="paramname"><em>teardown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the teardown function to call when the tree is destroyed. </p>
<p>This should normally be used with <a class="el" href="group__node.html#gaad3dea301d544aa434ca661ef3b913d1" title="Sets the custom pointer to pass to the tree callbacks, such as teardown. ">mpack_tree_set_context()</a> to register a custom pointer to pass to the teardown function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The MPack tree. </td></tr>
    <tr><td class="paramname">teardown</td><td>The function to call when the tree is destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga21aac296233a8a52d75cf7a1c57dd78f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_tree_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of bytes used in the buffer when the tree was parsed. </p>
<p>If there is something in the buffer after the MessagePack object (such as another object), this can be used to find it.</p>
<p>This is zero if an error occurred during tree parsing (since the portion of the data that the first complete object occupies cannot be determined if the data is invalid or corrupted.) </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
