<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>MPack: Expect API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-mpack-css.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MPack
   &#160;<span id="projectnumber">0.8.2</span>
   </div>
   <div id="projectbrief">A C encoding/decoding library for the MessagePack serialization format.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Expect API</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Description</h2>
<p>The MPack Expect API allows you to easily read MessagePack data when you expect it to follow a predefined schema. </p>
<p>See <a class="el" href="md_docs_expect.html">Using the Expect API</a> for examples.</p>
<p>The main purpose of the Expect API is convenience, so the API is lax. It automatically converts between similar types where there is no loss of precision.</p>
<p>When using any of the expect functions, if the type or value of what was read does not match what is expected, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised. </p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Basic Number Functions</h2></td></tr>
<tr class="memitem:gab1310dc54c39ac7754ee62d635a82976"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab1310dc54c39ac7754ee62d635a82976">mpack_expect_u8</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gab1310dc54c39ac7754ee62d635a82976"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an 8-bit unsigned integer.  <a href="#gab1310dc54c39ac7754ee62d635a82976">More...</a><br /></td></tr>
<tr class="separator:gab1310dc54c39ac7754ee62d635a82976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad267aebef43d94bc7891939d1fc2d51a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gad267aebef43d94bc7891939d1fc2d51a">mpack_expect_u16</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gad267aebef43d94bc7891939d1fc2d51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 16-bit unsigned integer.  <a href="#gad267aebef43d94bc7891939d1fc2d51a">More...</a><br /></td></tr>
<tr class="separator:gad267aebef43d94bc7891939d1fc2d51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb728859e5944214324a23979fe0aa2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaccb728859e5944214324a23979fe0aa2">mpack_expect_u32</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gaccb728859e5944214324a23979fe0aa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 32-bit unsigned integer.  <a href="#gaccb728859e5944214324a23979fe0aa2">More...</a><br /></td></tr>
<tr class="separator:gaccb728859e5944214324a23979fe0aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2dbbc0830bc08f2e7ce851782ec06e5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab2dbbc0830bc08f2e7ce851782ec06e5">mpack_expect_u64</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gab2dbbc0830bc08f2e7ce851782ec06e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 64-bit unsigned integer.  <a href="#gab2dbbc0830bc08f2e7ce851782ec06e5">More...</a><br /></td></tr>
<tr class="separator:gab2dbbc0830bc08f2e7ce851782ec06e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga728dc9cb317871bbf3360361a713d471"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga728dc9cb317871bbf3360361a713d471">mpack_expect_i8</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga728dc9cb317871bbf3360361a713d471"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an 8-bit signed integer.  <a href="#ga728dc9cb317871bbf3360361a713d471">More...</a><br /></td></tr>
<tr class="separator:ga728dc9cb317871bbf3360361a713d471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8ef3886fd34471e00136a672b6cfbfa"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gad8ef3886fd34471e00136a672b6cfbfa">mpack_expect_i16</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gad8ef3886fd34471e00136a672b6cfbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 16-bit signed integer.  <a href="#gad8ef3886fd34471e00136a672b6cfbfa">More...</a><br /></td></tr>
<tr class="separator:gad8ef3886fd34471e00136a672b6cfbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddca7f73951f581f0ddf03f6755322cf"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaddca7f73951f581f0ddf03f6755322cf">mpack_expect_i32</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gaddca7f73951f581f0ddf03f6755322cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 32-bit signed integer.  <a href="#gaddca7f73951f581f0ddf03f6755322cf">More...</a><br /></td></tr>
<tr class="separator:gaddca7f73951f581f0ddf03f6755322cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad93d24fe9e68a1dd94054b70095ebcfb"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gad93d24fe9e68a1dd94054b70095ebcfb">mpack_expect_i64</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gad93d24fe9e68a1dd94054b70095ebcfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 64-bit signed integer.  <a href="#gad93d24fe9e68a1dd94054b70095ebcfb">More...</a><br /></td></tr>
<tr class="separator:gad93d24fe9e68a1dd94054b70095ebcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49c6bea0c4d7e14a636d703ffe304264"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga49c6bea0c4d7e14a636d703ffe304264">mpack_expect_float</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga49c6bea0c4d7e14a636d703ffe304264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a number, returning the value as a float.  <a href="#ga49c6bea0c4d7e14a636d703ffe304264">More...</a><br /></td></tr>
<tr class="separator:ga49c6bea0c4d7e14a636d703ffe304264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51a47ece249cd4d6d795bf3211fde745"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga51a47ece249cd4d6d795bf3211fde745">mpack_expect_double</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga51a47ece249cd4d6d795bf3211fde745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a number, returning the value as a double.  <a href="#ga51a47ece249cd4d6d795bf3211fde745">More...</a><br /></td></tr>
<tr class="separator:ga51a47ece249cd4d6d795bf3211fde745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d56f4be6f5376ebfa6fcd0ebac6cce1"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga4d56f4be6f5376ebfa6fcd0ebac6cce1">mpack_expect_float_strict</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga4d56f4be6f5376ebfa6fcd0ebac6cce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a float.  <a href="#ga4d56f4be6f5376ebfa6fcd0ebac6cce1">More...</a><br /></td></tr>
<tr class="separator:ga4d56f4be6f5376ebfa6fcd0ebac6cce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad676ff64ce7933cade0c85da8a83799f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gad676ff64ce7933cade0c85da8a83799f">mpack_expect_double_strict</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gad676ff64ce7933cade0c85da8a83799f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a double.  <a href="#gad676ff64ce7933cade0c85da8a83799f">More...</a><br /></td></tr>
<tr class="separator:gad676ff64ce7933cade0c85da8a83799f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab217c0e2062b87129f948c6359c3825a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab217c0e2062b87129f948c6359c3825a">mpack_expect_uint</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gab217c0e2062b87129f948c6359c3825a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an unsigned int.  <a href="#gab217c0e2062b87129f948c6359c3825a">More...</a><br /></td></tr>
<tr class="separator:gab217c0e2062b87129f948c6359c3825a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae81b9d03f80e49501c9b9a695489315f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gae81b9d03f80e49501c9b9a695489315f">mpack_expect_int</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gae81b9d03f80e49501c9b9a695489315f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a signed int.  <a href="#gae81b9d03f80e49501c9b9a695489315f">More...</a><br /></td></tr>
<tr class="separator:gae81b9d03f80e49501c9b9a695489315f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Ranged Number Functions</h2></td></tr>
<tr class="memitem:gab3922088844e8cb301a6c2a5c5750d4f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab3922088844e8cb301a6c2a5c5750d4f">mpack_expect_u8_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint8_t min_value, uint8_t max_value)</td></tr>
<tr class="memdesc:gab3922088844e8cb301a6c2a5c5750d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an 8-bit unsigned integer, ensuring that it falls within the given range.  <a href="#gab3922088844e8cb301a6c2a5c5750d4f">More...</a><br /></td></tr>
<tr class="separator:gab3922088844e8cb301a6c2a5c5750d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6f984713bc3b24b044a99cd6f4e58b7"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gad6f984713bc3b24b044a99cd6f4e58b7">mpack_expect_u16_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint16_t min_value, uint16_t max_value)</td></tr>
<tr class="memdesc:gad6f984713bc3b24b044a99cd6f4e58b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 16-bit unsigned integer, ensuring that it falls within the given range.  <a href="#gad6f984713bc3b24b044a99cd6f4e58b7">More...</a><br /></td></tr>
<tr class="separator:gad6f984713bc3b24b044a99cd6f4e58b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e3a8ce7d88676ed38f7d4aaf22d0d9c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga1e3a8ce7d88676ed38f7d4aaf22d0d9c">mpack_expect_u32_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t min_value, uint32_t max_value)</td></tr>
<tr class="memdesc:ga1e3a8ce7d88676ed38f7d4aaf22d0d9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 32-bit unsigned integer, ensuring that it falls within the given range.  <a href="#ga1e3a8ce7d88676ed38f7d4aaf22d0d9c">More...</a><br /></td></tr>
<tr class="separator:ga1e3a8ce7d88676ed38f7d4aaf22d0d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7110dc658b713b292e9cafee3ccb7424"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga7110dc658b713b292e9cafee3ccb7424">mpack_expect_u64_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint64_t min_value, uint64_t max_value)</td></tr>
<tr class="memdesc:ga7110dc658b713b292e9cafee3ccb7424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 64-bit unsigned integer, ensuring that it falls within the given range.  <a href="#ga7110dc658b713b292e9cafee3ccb7424">More...</a><br /></td></tr>
<tr class="separator:ga7110dc658b713b292e9cafee3ccb7424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa42508b6153a3531961eb69c38d48bbc"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaa42508b6153a3531961eb69c38d48bbc">mpack_expect_uint_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, unsigned int min_value, unsigned int max_value)</td></tr>
<tr class="memdesc:gaa42508b6153a3531961eb69c38d48bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an unsigned integer, ensuring that it falls within the given range.  <a href="#gaa42508b6153a3531961eb69c38d48bbc">More...</a><br /></td></tr>
<tr class="separator:gaa42508b6153a3531961eb69c38d48bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga61459cbdd02c5b3db5292f9753a03ced"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga61459cbdd02c5b3db5292f9753a03ced">mpack_expect_u8_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint8_t max_value)</td></tr>
<tr class="memdesc:ga61459cbdd02c5b3db5292f9753a03ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an 8-bit unsigned integer, ensuring that it is at most <em>max_value</em>.  <a href="#ga61459cbdd02c5b3db5292f9753a03ced">More...</a><br /></td></tr>
<tr class="separator:ga61459cbdd02c5b3db5292f9753a03ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34cfd4d43ba388ff4f983b35c65c669a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga34cfd4d43ba388ff4f983b35c65c669a">mpack_expect_u16_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint16_t max_value)</td></tr>
<tr class="memdesc:ga34cfd4d43ba388ff4f983b35c65c669a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 16-bit unsigned integer, ensuring that it is at most <em>max_value</em>.  <a href="#ga34cfd4d43ba388ff4f983b35c65c669a">More...</a><br /></td></tr>
<tr class="separator:ga34cfd4d43ba388ff4f983b35c65c669a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4781e89d1712ae950b768362b8e98065"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga4781e89d1712ae950b768362b8e98065">mpack_expect_u32_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t max_value)</td></tr>
<tr class="memdesc:ga4781e89d1712ae950b768362b8e98065"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 32-bit unsigned integer, ensuring that it is at most <em>max_value</em>.  <a href="#ga4781e89d1712ae950b768362b8e98065">More...</a><br /></td></tr>
<tr class="separator:ga4781e89d1712ae950b768362b8e98065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5babd6ebf912abb4ed67ca8808f3ad0"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gac5babd6ebf912abb4ed67ca8808f3ad0">mpack_expect_u64_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint64_t max_value)</td></tr>
<tr class="memdesc:gac5babd6ebf912abb4ed67ca8808f3ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 64-bit unsigned integer, ensuring that it is at most <em>max_value</em>.  <a href="#gac5babd6ebf912abb4ed67ca8808f3ad0">More...</a><br /></td></tr>
<tr class="separator:gac5babd6ebf912abb4ed67ca8808f3ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga279a98fc2bb44cbf837fafc70df35bef"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga279a98fc2bb44cbf837fafc70df35bef">mpack_expect_uint_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, unsigned int max_value)</td></tr>
<tr class="memdesc:ga279a98fc2bb44cbf837fafc70df35bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an unsigned integer, ensuring that it is at most <em>max_value</em>.  <a href="#ga279a98fc2bb44cbf837fafc70df35bef">More...</a><br /></td></tr>
<tr class="separator:ga279a98fc2bb44cbf837fafc70df35bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa553c386f7ad6d05423835d31a439461"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaa553c386f7ad6d05423835d31a439461">mpack_expect_i8_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int8_t min_value, int8_t max_value)</td></tr>
<tr class="memdesc:gaa553c386f7ad6d05423835d31a439461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an 8-bit signed integer, ensuring that it falls within the given range.  <a href="#gaa553c386f7ad6d05423835d31a439461">More...</a><br /></td></tr>
<tr class="separator:gaa553c386f7ad6d05423835d31a439461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c4464418c0444854b3ab39785491a4b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga6c4464418c0444854b3ab39785491a4b">mpack_expect_i16_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int16_t min_value, int16_t max_value)</td></tr>
<tr class="memdesc:ga6c4464418c0444854b3ab39785491a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 16-bit signed integer, ensuring that it falls within the given range.  <a href="#ga6c4464418c0444854b3ab39785491a4b">More...</a><br /></td></tr>
<tr class="separator:ga6c4464418c0444854b3ab39785491a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga217f2065c5f039209f93cddbdbf01bee"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga217f2065c5f039209f93cddbdbf01bee">mpack_expect_i32_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int32_t min_value, int32_t max_value)</td></tr>
<tr class="memdesc:ga217f2065c5f039209f93cddbdbf01bee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 32-bit signed integer, ensuring that it falls within the given range.  <a href="#ga217f2065c5f039209f93cddbdbf01bee">More...</a><br /></td></tr>
<tr class="separator:ga217f2065c5f039209f93cddbdbf01bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7356f1e0638a076fac1a8db87f4f53"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga7f7356f1e0638a076fac1a8db87f4f53">mpack_expect_i64_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int64_t min_value, int64_t max_value)</td></tr>
<tr class="memdesc:ga7f7356f1e0638a076fac1a8db87f4f53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 64-bit signed integer, ensuring that it falls within the given range.  <a href="#ga7f7356f1e0638a076fac1a8db87f4f53">More...</a><br /></td></tr>
<tr class="separator:ga7f7356f1e0638a076fac1a8db87f4f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga749d58ee5e884bce54b9767e7ee56c39"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga749d58ee5e884bce54b9767e7ee56c39">mpack_expect_int_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int min_value, int max_value)</td></tr>
<tr class="memdesc:ga749d58ee5e884bce54b9767e7ee56c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a signed integer, ensuring that it falls within the given range.  <a href="#ga749d58ee5e884bce54b9767e7ee56c39">More...</a><br /></td></tr>
<tr class="separator:ga749d58ee5e884bce54b9767e7ee56c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1436e08a6cb710bf11dabff20188f67b"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga1436e08a6cb710bf11dabff20188f67b">mpack_expect_i8_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int8_t max_value)</td></tr>
<tr class="memdesc:ga1436e08a6cb710bf11dabff20188f67b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an 8-bit signed integer, ensuring that it is at least zero and at most <em>max_value</em>.  <a href="#ga1436e08a6cb710bf11dabff20188f67b">More...</a><br /></td></tr>
<tr class="separator:ga1436e08a6cb710bf11dabff20188f67b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ac3f09e7eb21aec1926aaff0ca37128"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga4ac3f09e7eb21aec1926aaff0ca37128">mpack_expect_i16_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int16_t max_value)</td></tr>
<tr class="memdesc:ga4ac3f09e7eb21aec1926aaff0ca37128"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 16-bit signed integer, ensuring that it is at least zero and at most <em>max_value</em>.  <a href="#ga4ac3f09e7eb21aec1926aaff0ca37128">More...</a><br /></td></tr>
<tr class="separator:ga4ac3f09e7eb21aec1926aaff0ca37128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacb9b77aa647947a1e47ab851c715cf6a"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gacb9b77aa647947a1e47ab851c715cf6a">mpack_expect_i32_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int32_t max_value)</td></tr>
<tr class="memdesc:gacb9b77aa647947a1e47ab851c715cf6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 32-bit signed integer, ensuring that it is at least zero and at most <em>max_value</em>.  <a href="#gacb9b77aa647947a1e47ab851c715cf6a">More...</a><br /></td></tr>
<tr class="separator:gacb9b77aa647947a1e47ab851c715cf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7354498073dfd3583db72591931d22a2"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga7354498073dfd3583db72591931d22a2">mpack_expect_i64_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int64_t max_value)</td></tr>
<tr class="memdesc:ga7354498073dfd3583db72591931d22a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a 64-bit signed integer, ensuring that it is at least zero and at most <em>max_value</em>.  <a href="#ga7354498073dfd3583db72591931d22a2">More...</a><br /></td></tr>
<tr class="separator:ga7354498073dfd3583db72591931d22a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a28a0a5daeeb9b4f10d2169d309f5eb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga7a28a0a5daeeb9b4f10d2169d309f5eb">mpack_expect_int_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int max_value)</td></tr>
<tr class="memdesc:ga7a28a0a5daeeb9b4f10d2169d309f5eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an int, ensuring that it is at least zero and at most <em>max_value</em>.  <a href="#ga7a28a0a5daeeb9b4f10d2169d309f5eb">More...</a><br /></td></tr>
<tr class="separator:ga7a28a0a5daeeb9b4f10d2169d309f5eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fffadf5032a669d582025f5131b53e2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga0fffadf5032a669d582025f5131b53e2">mpack_expect_float_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, float min_value, float max_value)</td></tr>
<tr class="memdesc:ga0fffadf5032a669d582025f5131b53e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a number, ensuring that it falls within the given range and returning the value as a float.  <a href="#ga0fffadf5032a669d582025f5131b53e2">More...</a><br /></td></tr>
<tr class="separator:ga0fffadf5032a669d582025f5131b53e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63f44e3d23db5e24d86b0b714f9ff95b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga63f44e3d23db5e24d86b0b714f9ff95b">mpack_expect_double_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, double min_value, double max_value)</td></tr>
<tr class="memdesc:ga63f44e3d23db5e24d86b0b714f9ff95b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a number, ensuring that it falls within the given range and returning the value as a double.  <a href="#ga63f44e3d23db5e24d86b0b714f9ff95b">More...</a><br /></td></tr>
<tr class="separator:ga63f44e3d23db5e24d86b0b714f9ff95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Matching Number Functions</h2></td></tr>
<tr class="memitem:ga005303e0b2c39809fcd5172228fae282"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga005303e0b2c39809fcd5172228fae282">mpack_expect_uint_match</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint64_t value)</td></tr>
<tr class="memdesc:ga005303e0b2c39809fcd5172228fae282"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an unsigned integer, ensuring that it exactly matches the given value.  <a href="#ga005303e0b2c39809fcd5172228fae282">More...</a><br /></td></tr>
<tr class="separator:ga005303e0b2c39809fcd5172228fae282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8992b669afbaffee6ac8f336022611aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga8992b669afbaffee6ac8f336022611aa">mpack_expect_int_match</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int64_t value)</td></tr>
<tr class="memdesc:ga8992b669afbaffee6ac8f336022611aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a signed integer, ensuring that it exactly matches the given value.  <a href="#ga8992b669afbaffee6ac8f336022611aa">More...</a><br /></td></tr>
<tr class="separator:ga8992b669afbaffee6ac8f336022611aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Other Basic Types</h2></td></tr>
<tr class="memitem:gada69acbd6803f79cab7573ae9ebc37bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gada69acbd6803f79cab7573ae9ebc37bd">mpack_expect_nil</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gada69acbd6803f79cab7573ae9ebc37bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nil, raising <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> if the value is not nil.  <a href="#gada69acbd6803f79cab7573ae9ebc37bd">More...</a><br /></td></tr>
<tr class="separator:gada69acbd6803f79cab7573ae9ebc37bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeafa42ca3ae974494f127eb4b56ed8ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaeafa42ca3ae974494f127eb4b56ed8ae">mpack_expect_bool</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gaeafa42ca3ae974494f127eb4b56ed8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a boolean.  <a href="#gaeafa42ca3ae974494f127eb4b56ed8ae">More...</a><br /></td></tr>
<tr class="separator:gaeafa42ca3ae974494f127eb4b56ed8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadfca446696881a598cc4f90892ded88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaadfca446696881a598cc4f90892ded88">mpack_expect_true</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gaadfca446696881a598cc4f90892ded88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a boolean, raising <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> if its value is not <code>true</code>.  <a href="#gaadfca446696881a598cc4f90892ded88">More...</a><br /></td></tr>
<tr class="separator:gaadfca446696881a598cc4f90892ded88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa29ab364a7ae092e93a20b1a24744c0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaa29ab364a7ae092e93a20b1a24744c0e">mpack_expect_false</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gaa29ab364a7ae092e93a20b1a24744c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a boolean, raising <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> if its value is not <code>false</code>.  <a href="#gaa29ab364a7ae092e93a20b1a24744c0e">More...</a><br /></td></tr>
<tr class="separator:gaa29ab364a7ae092e93a20b1a24744c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Compound Types</h2></td></tr>
<tr class="memitem:ga44a2941b8e8ec379748c238fab52bda1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga44a2941b8e8ec379748c238fab52bda1">mpack_expect_map</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga44a2941b8e8ec379748c238fab52bda1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a map, returning its element count.  <a href="#ga44a2941b8e8ec379748c238fab52bda1">More...</a><br /></td></tr>
<tr class="separator:ga44a2941b8e8ec379748c238fab52bda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2d131161862c386e9f048ad93fb3d45"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaa2d131161862c386e9f048ad93fb3d45">mpack_expect_map_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t min_count, uint32_t max_count)</td></tr>
<tr class="memdesc:gaa2d131161862c386e9f048ad93fb3d45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a map with a number of elements in the given range, returning its element count.  <a href="#gaa2d131161862c386e9f048ad93fb3d45">More...</a><br /></td></tr>
<tr class="separator:gaa2d131161862c386e9f048ad93fb3d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36d86c85877f94aa7b493aaa739c8849"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga36d86c85877f94aa7b493aaa739c8849">mpack_expect_map_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t max_count)</td></tr>
<tr class="memdesc:ga36d86c85877f94aa7b493aaa739c8849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a map with a number of elements at most <em>max_count</em>, returning its element count.  <a href="#ga36d86c85877f94aa7b493aaa739c8849">More...</a><br /></td></tr>
<tr class="separator:ga36d86c85877f94aa7b493aaa739c8849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab66c8c170be1b394b397ccc041d6c133"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab66c8c170be1b394b397ccc041d6c133">mpack_expect_map_match</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t count)</td></tr>
<tr class="memdesc:gab66c8c170be1b394b397ccc041d6c133"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a map of the exact size given.  <a href="#gab66c8c170be1b394b397ccc041d6c133">More...</a><br /></td></tr>
<tr class="separator:gab66c8c170be1b394b397ccc041d6c133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee3ac5d2ea0dc864b5898673a67c69ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaee3ac5d2ea0dc864b5898673a67c69ee">mpack_expect_map_or_nil</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t *count)</td></tr>
<tr class="memdesc:gaee3ac5d2ea0dc864b5898673a67c69ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nil node or the start of a map, returning whether a map was read and placing its number of key/value pairs in count.  <a href="#gaee3ac5d2ea0dc864b5898673a67c69ee">More...</a><br /></td></tr>
<tr class="separator:gaee3ac5d2ea0dc864b5898673a67c69ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aae8867b092afd5a2350d4701687b35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga2aae8867b092afd5a2350d4701687b35">mpack_expect_map_max_or_nil</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t max_count, uint32_t *count)</td></tr>
<tr class="memdesc:ga2aae8867b092afd5a2350d4701687b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nil node or the start of a map with a number of elements at most max_count, returning whether a map was read and placing its number of key/value pairs in count.  <a href="#ga2aae8867b092afd5a2350d4701687b35">More...</a><br /></td></tr>
<tr class="separator:ga2aae8867b092afd5a2350d4701687b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18285492fd04458fb7ab0d151bea0402"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga18285492fd04458fb7ab0d151bea0402">mpack_expect_array</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga18285492fd04458fb7ab0d151bea0402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of an array, returning its element count.  <a href="#ga18285492fd04458fb7ab0d151bea0402">More...</a><br /></td></tr>
<tr class="separator:ga18285492fd04458fb7ab0d151bea0402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c0b7dd785576183e5444691c7d32b90"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga4c0b7dd785576183e5444691c7d32b90">mpack_expect_array_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t min_count, uint32_t max_count)</td></tr>
<tr class="memdesc:ga4c0b7dd785576183e5444691c7d32b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of an array with a number of elements in the given range, returning its element count.  <a href="#ga4c0b7dd785576183e5444691c7d32b90">More...</a><br /></td></tr>
<tr class="separator:ga4c0b7dd785576183e5444691c7d32b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e1599675ca83c5c03af8de220b9a826"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga3e1599675ca83c5c03af8de220b9a826">mpack_expect_array_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t max_count)</td></tr>
<tr class="memdesc:ga3e1599675ca83c5c03af8de220b9a826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of an array with a number of elements at most <em>max_count</em>, returning its element count.  <a href="#ga3e1599675ca83c5c03af8de220b9a826">More...</a><br /></td></tr>
<tr class="separator:ga3e1599675ca83c5c03af8de220b9a826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga799bb820a49f5a8a70e604466f8ab9b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga799bb820a49f5a8a70e604466f8ab9b5">mpack_expect_array_match</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t count)</td></tr>
<tr class="memdesc:ga799bb820a49f5a8a70e604466f8ab9b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of an array of the exact size given.  <a href="#ga799bb820a49f5a8a70e604466f8ab9b5">More...</a><br /></td></tr>
<tr class="separator:ga799bb820a49f5a8a70e604466f8ab9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f3202b0ed8916b311e2c225172afdb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga2f3202b0ed8916b311e2c225172afdb3">mpack_expect_array_or_nil</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t *count)</td></tr>
<tr class="memdesc:ga2f3202b0ed8916b311e2c225172afdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nil node or the start of an array, returning whether an array was read and placing its number of elements in count.  <a href="#ga2f3202b0ed8916b311e2c225172afdb3">More...</a><br /></td></tr>
<tr class="separator:ga2f3202b0ed8916b311e2c225172afdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ad5153a6d29bebf8251ba5beb1aaef3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga0ad5153a6d29bebf8251ba5beb1aaef3">mpack_expect_array_max_or_nil</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t max_count, uint32_t *count)</td></tr>
<tr class="memdesc:ga0ad5153a6d29bebf8251ba5beb1aaef3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nil node or the start of an array with a number of elements at most max_count, returning whether an array was read and placing its number of key/value pairs in count.  <a href="#ga0ad5153a6d29bebf8251ba5beb1aaef3">More...</a><br /></td></tr>
<tr class="separator:ga0ad5153a6d29bebf8251ba5beb1aaef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e69ee365f459dec5cdc3c797c7d0642"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga7e69ee365f459dec5cdc3c797c7d0642">mpack_expect_array_alloc</a>(reader,  Type,  max_count,  out_count)</td></tr>
<tr class="memdesc:ga7e69ee365f459dec5cdc3c797c7d0642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of an array and allocates storage for it, placing its size in out_count.  <a href="#ga7e69ee365f459dec5cdc3c797c7d0642">More...</a><br /></td></tr>
<tr class="separator:ga7e69ee365f459dec5cdc3c797c7d0642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccad78065b48e2fd3c15c32e91927a75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaccad78065b48e2fd3c15c32e91927a75">mpack_expect_array_or_nil_alloc</a>(reader,  Type,  max_count,  out_count)</td></tr>
<tr class="memdesc:gaccad78065b48e2fd3c15c32e91927a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a nil node or the start of an array and allocates storage for it, placing its size in out_count.  <a href="#gaccad78065b48e2fd3c15c32e91927a75">More...</a><br /></td></tr>
<tr class="separator:gaccad78065b48e2fd3c15c32e91927a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
String Functions</h2></td></tr>
<tr class="memitem:ga6baba88194988c9f423630052d59f7fd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga6baba88194988c9f423630052d59f7fd">mpack_expect_str</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:ga6baba88194988c9f423630052d59f7fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a string, returning its size in bytes.  <a href="#ga6baba88194988c9f423630052d59f7fd">More...</a><br /></td></tr>
<tr class="separator:ga6baba88194988c9f423630052d59f7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga658205c994cf8fce528f4c8a3a957a14"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga658205c994cf8fce528f4c8a3a957a14">mpack_expect_str_buf</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *buf, size_t bufsize)</td></tr>
<tr class="memdesc:ga658205c994cf8fce528f4c8a3a957a14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string of at most the given size, writing it into the given buffer and returning its size in bytes.  <a href="#ga658205c994cf8fce528f4c8a3a957a14">More...</a><br /></td></tr>
<tr class="separator:ga658205c994cf8fce528f4c8a3a957a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c44c450649514ee1a31e567d39f0bf0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga8c44c450649514ee1a31e567d39f0bf0">mpack_expect_utf8</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *buf, size_t bufsize)</td></tr>
<tr class="memdesc:ga8c44c450649514ee1a31e567d39f0bf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string into the given buffer, ensuring it is a valid UTF-8 string and returning its size in bytes.  <a href="#ga8c44c450649514ee1a31e567d39f0bf0">More...</a><br /></td></tr>
<tr class="separator:ga8c44c450649514ee1a31e567d39f0bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00a055c4e4c68485757e1eee17f8db85"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga00a055c4e4c68485757e1eee17f8db85">mpack_expect_str_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t maxsize)</td></tr>
<tr class="memdesc:ga00a055c4e4c68485757e1eee17f8db85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a string, raising an error if its length is not at most the given number of bytes (not including any null-terminator.)  <a href="#ga00a055c4e4c68485757e1eee17f8db85">More...</a><br /></td></tr>
<tr class="separator:ga00a055c4e4c68485757e1eee17f8db85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac189c3ea2b957e594854fc2c8cae3cbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gac189c3ea2b957e594854fc2c8cae3cbd">mpack_expect_str_length</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t count)</td></tr>
<tr class="memdesc:gac189c3ea2b957e594854fc2c8cae3cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a string, raising an error if its length is not exactly the given number of bytes (not including any null-terminator.)  <a href="#gac189c3ea2b957e594854fc2c8cae3cbd">More...</a><br /></td></tr>
<tr class="separator:gac189c3ea2b957e594854fc2c8cae3cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ceade6375ab699c1ef05ef9f5c2ff90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga3ceade6375ab699c1ef05ef9f5c2ff90">mpack_expect_str_match</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, const char *str, size_t length)</td></tr>
<tr class="memdesc:ga3ceade6375ab699c1ef05ef9f5c2ff90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string, ensuring it exactly matches the given string.  <a href="#ga3ceade6375ab699c1ef05ef9f5c2ff90">More...</a><br /></td></tr>
<tr class="separator:ga3ceade6375ab699c1ef05ef9f5c2ff90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94489d03628c1fb1a3d0ac6971600fe8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga94489d03628c1fb1a3d0ac6971600fe8">mpack_expect_cstr</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *buf, size_t size)</td></tr>
<tr class="memdesc:ga94489d03628c1fb1a3d0ac6971600fe8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string into the given buffer, ensures it has no null bytes, and adds a null-terminator at the end.  <a href="#ga94489d03628c1fb1a3d0ac6971600fe8">More...</a><br /></td></tr>
<tr class="separator:ga94489d03628c1fb1a3d0ac6971600fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62be63032f3c84181eeed4609f0dddb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga62be63032f3c84181eeed4609f0dddb4">mpack_expect_utf8_cstr</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *buf, size_t size)</td></tr>
<tr class="memdesc:ga62be63032f3c84181eeed4609f0dddb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string into the given buffer, ensures it is a valid UTF-8 string without NUL characters, and adds a null-terminator at the end.  <a href="#ga62be63032f3c84181eeed4609f0dddb4">More...</a><br /></td></tr>
<tr class="separator:ga62be63032f3c84181eeed4609f0dddb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6d2d920a0ed7d39e251ac8d6f077998"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab6d2d920a0ed7d39e251ac8d6f077998">mpack_expect_cstr_alloc</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, size_t maxsize)</td></tr>
<tr class="memdesc:gab6d2d920a0ed7d39e251ac8d6f077998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string with the given total maximum size (including space for a null-terminator), allocates storage for it, ensures it has no null-bytes, and adds a null-terminator at the end.  <a href="#gab6d2d920a0ed7d39e251ac8d6f077998">More...</a><br /></td></tr>
<tr class="separator:gab6d2d920a0ed7d39e251ac8d6f077998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5acb7f64d13ce1a09670377cbbbf68c7"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga5acb7f64d13ce1a09670377cbbbf68c7">mpack_expect_utf8_cstr_alloc</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, size_t maxsize)</td></tr>
<tr class="memdesc:ga5acb7f64d13ce1a09670377cbbbf68c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string with the given total maximum size (including space for a null-terminator), allocates storage for it, ensures it is valid UTF-8 with no null-bytes, and adds a null-terminator at the end.  <a href="#ga5acb7f64d13ce1a09670377cbbbf68c7">More...</a><br /></td></tr>
<tr class="separator:ga5acb7f64d13ce1a09670377cbbbf68c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f16d7ec771277e1be2a35ea0573db31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga8f16d7ec771277e1be2a35ea0573db31">mpack_expect_cstr_match</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, const char *str)</td></tr>
<tr class="memdesc:ga8f16d7ec771277e1be2a35ea0573db31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a string, ensuring it exactly matches the given null-terminated string.  <a href="#ga8f16d7ec771277e1be2a35ea0573db31">More...</a><br /></td></tr>
<tr class="separator:ga8f16d7ec771277e1be2a35ea0573db31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Binary Data / Extension Functions</h2></td></tr>
<tr class="memitem:gadcf7fc94ae30ed5c3752291a0efd43c5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gadcf7fc94ae30ed5c3752291a0efd43c5">mpack_expect_bin</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="memdesc:gadcf7fc94ae30ed5c3752291a0efd43c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a binary blob, returning its size in bytes.  <a href="#gadcf7fc94ae30ed5c3752291a0efd43c5">More...</a><br /></td></tr>
<tr class="separator:gadcf7fc94ae30ed5c3752291a0efd43c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga443df58ec3a12d76502dad5864f793e2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga443df58ec3a12d76502dad5864f793e2">mpack_expect_bin_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t maxsize)</td></tr>
<tr class="memdesc:ga443df58ec3a12d76502dad5864f793e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a binary blob, raising an error if its length is not at most the given number of bytes.  <a href="#ga443df58ec3a12d76502dad5864f793e2">More...</a><br /></td></tr>
<tr class="separator:ga443df58ec3a12d76502dad5864f793e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae83eff20642825f13771a2cdceaa7cbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gae83eff20642825f13771a2cdceaa7cbd">mpack_expect_bin_size</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t count)</td></tr>
<tr class="memdesc:gae83eff20642825f13771a2cdceaa7cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the start of a binary blob, raising an error if its length is not exactly the given number of bytes.  <a href="#gae83eff20642825f13771a2cdceaa7cbd">More...</a><br /></td></tr>
<tr class="separator:gae83eff20642825f13771a2cdceaa7cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98004c26b9ebc1b80b4bdec5a1d4b093"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga98004c26b9ebc1b80b4bdec5a1d4b093">mpack_expect_bin_buf</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *buf, size_t size)</td></tr>
<tr class="memdesc:ga98004c26b9ebc1b80b4bdec5a1d4b093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a binary blob into the given buffer, returning its size in bytes.  <a href="#ga98004c26b9ebc1b80b4bdec5a1d4b093">More...</a><br /></td></tr>
<tr class="separator:ga98004c26b9ebc1b80b4bdec5a1d4b093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga513a9ce0e5bf78128d2d174bf1434538"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga513a9ce0e5bf78128d2d174bf1434538">mpack_expect_bin_alloc</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, size_t maxsize, size_t *size)</td></tr>
<tr class="memdesc:ga513a9ce0e5bf78128d2d174bf1434538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a binary blob with the given total maximum size, allocating storage for it.  <a href="#ga513a9ce0e5bf78128d2d174bf1434538">More...</a><br /></td></tr>
<tr class="separator:ga513a9ce0e5bf78128d2d174bf1434538"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Special Functions</h2></td></tr>
<tr class="memitem:ga6e9c48430fa233615ec9b5439f9ed451"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga6e9c48430fa233615ec9b5439f9ed451">mpack_expect_tag</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__common.html#structmpack__tag__t">mpack_tag_t</a> tag)</td></tr>
<tr class="memdesc:ga6e9c48430fa233615ec9b5439f9ed451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a MessagePack object header (an MPack tag), expecting it to exactly match the given tag.  <a href="#ga6e9c48430fa233615ec9b5439f9ed451">More...</a><br /></td></tr>
<tr class="separator:ga6e9c48430fa233615ec9b5439f9ed451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65a2a909774f3205887ae446ea4089f0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga65a2a909774f3205887ae446ea4089f0">mpack_expect_enum</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, const char *strings[], size_t count)</td></tr>
<tr class="memdesc:ga65a2a909774f3205887ae446ea4089f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expects a string matching one of the strings in the given array, returning its array index.  <a href="#ga65a2a909774f3205887ae446ea4089f0">More...</a><br /></td></tr>
<tr class="separator:ga65a2a909774f3205887ae446ea4089f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5763a0063111ffdfe8f193fb42e7fea4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga5763a0063111ffdfe8f193fb42e7fea4">mpack_expect_enum_optional</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, const char *strings[], size_t count)</td></tr>
<tr class="memdesc:ga5763a0063111ffdfe8f193fb42e7fea4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expects a string matching one of the strings in the given array returning its array index, or <em>count</em> if no strings match.  <a href="#ga5763a0063111ffdfe8f193fb42e7fea4">More...</a><br /></td></tr>
<tr class="separator:ga5763a0063111ffdfe8f193fb42e7fea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78f80d9fabe961d661eabe95732c2d59"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga78f80d9fabe961d661eabe95732c2d59">mpack_expect_key_uint</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, bool found[], size_t count)</td></tr>
<tr class="memdesc:ga78f80d9fabe961d661eabe95732c2d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expects an unsigned integer map key between 0 and count-1, marking it as found in the given bool array and returning it.  <a href="#ga78f80d9fabe961d661eabe95732c2d59">More...</a><br /></td></tr>
<tr class="separator:ga78f80d9fabe961d661eabe95732c2d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada27a479e6ad56faaa14528d1a3dfb26"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gada27a479e6ad56faaa14528d1a3dfb26">mpack_expect_key_cstr</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, const char *keys[], bool found[], size_t count)</td></tr>
<tr class="memdesc:gada27a479e6ad56faaa14528d1a3dfb26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expects a string map key matching one of the strings in the given key list, marking it as found in the given bool array and returning its index.  <a href="#gada27a479e6ad56faaa14528d1a3dfb26">More...</a><br /></td></tr>
<tr class="separator:gada27a479e6ad56faaa14528d1a3dfb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga7e69ee365f459dec5cdc3c797c7d0642"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mpack_expect_array_alloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reader, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">max_count, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">out_count&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of an array and allocates storage for it, placing its size in out_count. </p>
<p>A number of objects follow equal to the element count of the array. You must call <a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06">mpack_done_array()</a> when done (even if the element count is zero.)</p>
<p>If an error occurs, NULL is returned and the reader is placed in an error state.</p>
<p>If the count is zero, NULL is returned. This does not indicate error. You should not check the return value for NULL to check for errors; only check the reader's error state.</p>
<p>The allocated array must be freed with <a class="el" href="group__config.html#ga298d7c2e4093bcfe361088df9e35956a" title="Defines the memory free function used by MPack. ">MPACK_FREE()</a> (or simply free() if MPack's allocator hasn't been customized.)</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not an array or if its size is greater than max_count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaccad78065b48e2fd3c15c32e91927a75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mpack_expect_array_or_nil_alloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reader, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">max_count, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">out_count&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nil node or the start of an array and allocates storage for it, placing its size in out_count. </p>
<p>A number of objects follow equal to the element count of the array if a non-empty array was read.</p>
<p>If an error occurs, NULL is returned and the reader is placed in an error state.</p>
<p>If a nil node was read, NULL is returned. If an empty array was read, <a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06" title="Finishes reading an array. ">mpack_done_array()</a> is called automatically and NULL is returned. These do not indicate error. You should not check the return value for NULL to check for errors; only check the reader's error state.</p>
<p>The allocated array must be freed with <a class="el" href="group__config.html#ga298d7c2e4093bcfe361088df9e35956a" title="Defines the memory free function used by MPack. ">MPACK_FREE()</a> (or simply free() if MPack's allocator hasn't been customized.)</p>
<dl class="section warning"><dt>Warning</dt><dd>You must call <a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06">mpack_done_array()</a> if and only if a non-zero element count is read. This function does not differentiate between nil and an empty array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not an array or if its size is greater than max_count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga18285492fd04458fb7ab0d151bea0402"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of an array, returning its element count. </p>
<p>A number of values follow equal to the element count of the array. <a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06">mpack_done_array()</a> must be called once all elements have been read.</p>
<dl class="section warning"><dt>Warning</dt><dd>This call is dangerous! It does not have a size limit, and it does not have any way of checking whether there is enough data in the message (since the data could be coming from a stream.) When looping through the array's contents, you must check for errors on each iteration of the loop. Otherwise an attacker could craft a message declaring an array of a billion elements which would throw your parsing code into an infinite loop! You should strongly consider using <a class="el" href="group__expect.html#ga3e1599675ca83c5c03af8de220b9a826" title="Reads the start of an array with a number of elements at most max_count, returning its element count...">mpack_expect_array_max()</a> with a safe maximum size instead. </dd></dl>

</div>
</div>
<a class="anchor" id="ga799bb820a49f5a8a70e604466f8ab9b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_array_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of an array of the exact size given. </p>
<p>A number of values follow equal to the element count of the array. <a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06">mpack_done_array()</a> must be called once all elements have been read.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not an array or if its size does not match the given count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3e1599675ca83c5c03af8de220b9a826"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_array_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of an array with a number of elements at most <em>max_count</em>, returning its element count. </p>
<p>A number of values follow equal to the element count of the array. <a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06">mpack_done_array()</a> must be called once all elements have been read.</p>
<p>Zero is returned if an error occurs.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not an array or if its size is greater than max_count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0ad5153a6d29bebf8251ba5beb1aaef3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_expect_array_max_or_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nil node or the start of an array with a number of elements at most max_count, returning whether an array was read and placing its number of key/value pairs in count. </p>
<p>If an array was read, a number of values follow equal to the element count of the array. <a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06">mpack_done_array()</a> should also be called once all elements have been read (only if an array was read.)</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an array was read successfully; <code>false</code> if nil was read or an error occured. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a nil or array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2f3202b0ed8916b311e2c225172afdb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_expect_array_or_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nil node or the start of an array, returning whether an array was read and placing its number of elements in count. </p>
<p>If an array was read, a number of values follow equal to the element count of the array. <a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06">mpack_done_array()</a> should also be called once all elements have been read (only if an array was read.)</p>
<dl class="section warning"><dt>Warning</dt><dd>This call is dangerous! It does not have a size limit, and it does not have any way of checking whether there is enough data in the message (since the data could be coming from a stream.) When looping through the array's contents, you must check for errors on each iteration of the loop. Otherwise an attacker could craft a message declaring an array of a billion elements which would throw your parsing code into an infinite loop! You should strongly consider using <a class="el" href="group__expect.html#ga0ad5153a6d29bebf8251ba5beb1aaef3" title="Reads a nil node or the start of an array with a number of elements at most max_count, returning whether an array was read and placing its number of key/value pairs in count. ">mpack_expect_array_max_or_nil()</a> with a safe maximum size instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an array was read successfully; <code>false</code> if nil was read or an error occured. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a nil or array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4c0b7dd785576183e5444691c7d32b90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_array_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>min_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of an array with a number of elements in the given range, returning its element count. </p>
<p>A number of values follow equal to the element count of the array. <a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06">mpack_done_array()</a> must be called once all elements have been read.</p>
<p>min_count is returned if an error occurs.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not an array or if its size does not fall within the given range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gadcf7fc94ae30ed5c3752291a0efd43c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_bin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a binary blob, returning its size in bytes. </p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object, copying them into the given buffer...">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572" title="Reads bytes from a string, binary blob or extension object in-place in the buffer. ">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaa4676c4b0761de4f864fd81c347a15a0">mpack_done_bin()</a> must be called once all bytes have been read.</p>
<p>mpack_error_type is raised if the value is not a binary blob. </p>

</div>
</div>
<a class="anchor" id="ga513a9ce0e5bf78128d2d174bf1434538"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_expect_bin_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a binary blob with the given total maximum size, allocating storage for it. </p>

</div>
</div>
<a class="anchor" id="ga98004c26b9ebc1b80b4bdec5a1d4b093"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_expect_bin_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a binary blob into the given buffer, returning its size in bytes. </p>
<p>For compatibility, this will accept if the underlying type is string or binary (since in MessagePack 1.0, strings and binary data were combined under the "raw" type which became string in 1.1.) </p>

</div>
</div>
<a class="anchor" id="ga443df58ec3a12d76502dad5864f793e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_bin_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a binary blob, raising an error if its length is not at most the given number of bytes. </p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object, copying them into the given buffer...">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572" title="Reads bytes from a string, binary blob or extension object in-place in the buffer. ">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaa4676c4b0761de4f864fd81c347a15a0">mpack_done_bin()</a> must be called once all bytes have been read.</p>
<p>mpack_error_type is raised if the value is not a binary blob or if its length does not match. </p>

</div>
</div>
<a class="anchor" id="gae83eff20642825f13771a2cdceaa7cbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_bin_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a binary blob, raising an error if its length is not exactly the given number of bytes. </p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object, copying them into the given buffer...">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572" title="Reads bytes from a string, binary blob or extension object in-place in the buffer. ">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaa4676c4b0761de4f864fd81c347a15a0">mpack_done_bin()</a> must be called once all bytes have been read.</p>
<p>mpack_error_type is raised if the value is not a binary blob or if its length does not match. </p>

</div>
</div>
<a class="anchor" id="gaeafa42ca3ae974494f127eb4b56ed8ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_expect_bool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a boolean. </p>
<dl class="section note"><dt>Note</dt><dd>Integers will raise mpack_error_type; the value must be strictly a boolean. </dd></dl>

</div>
</div>
<a class="anchor" id="ga94489d03628c1fb1a3d0ac6971600fe8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string into the given buffer, ensures it has no null bytes, and adds a null-terminator at the end. </p>
<p>Raises mpack_error_too_big if there is not enough room for the string and null-terminator. Raises mpack_error_type if the value is not a string or contains a null byte. </p>

</div>
</div>
<a class="anchor" id="gab6d2d920a0ed7d39e251ac8d6f077998"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_expect_cstr_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string with the given total maximum size (including space for a null-terminator), allocates storage for it, ensures it has no null-bytes, and adds a null-terminator at the end. </p>
<p>You assume ownership of the returned pointer if reading succeeds.</p>
<p>The allocated string must be freed with <a class="el" href="group__config.html#ga298d7c2e4093bcfe361088df9e35956a" title="Defines the memory free function used by MPack. ">MPACK_FREE()</a> (or simply free() if MPack's allocator hasn't been customized.)</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_too_big</td><td>if the string plus null-terminator is larger than the given maxsize. </td></tr>
    <tr><td class="paramname">mpack_error_invalid</td><td>if the value is not a string or contains a null byte. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8f16d7ec771277e1be2a35ea0573db31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_cstr_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string, ensuring it exactly matches the given null-terminated string. </p>
<p>Remember that maps are unordered in JSON. Don't use this for map keys unless the map has only a single key! </p>

</div>
</div>
<a class="anchor" id="ga51a47ece249cd4d6d795bf3211fde745"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mpack_expect_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a number, returning the value as a double. </p>
<p>The underlying value can be an integer, float or double; the value is converted to a double.</p>
<dl class="section note"><dt>Note</dt><dd>Reading a very large integer with this function can incur a loss of precision.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float, double or integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga63f44e3d23db5e24d86b0b714f9ff95b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mpack_expect_double_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a number, ensuring that it falls within the given range and returning the value as a double. </p>
<p>The underlying value can be an integer, float or double; the value is converted to a double.</p>
<dl class="section note"><dt>Note</dt><dd>Reading a very large integer with this function can incur a loss of precision.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float, double or integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad676ff64ce7933cade0c85da8a83799f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mpack_expect_double_strict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a double. </p>
<p>The underlying value must be a float or double, not an integer. This ensures no loss of precision can occur.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float or double. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga65a2a909774f3205887ae446ea4089f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_expect_enum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>strings</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expects a string matching one of the strings in the given array, returning its array index. </p>
<p>If the value does not match any of the given strings, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is flagged. Use <a class="el" href="group__expect.html#ga5763a0063111ffdfe8f193fb42e7fea4" title="Expects a string matching one of the strings in the given array returning its array index...">mpack_expect_enum_optional()</a> if you want to allow other values than the given strings.</p>
<p>If any error occurs or the reader is in an error state, <em>count</em> is returned.</p>
<p>This can be used to quickly parse a string into an enum when the enum values range from 0 to <em>count-1</em>. If the last value in the enum is a special "count" value, it can be passed as the count, and the return value can be cast directly to the enum type.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>           { APPLE ,  BANANA ,  ORANGE , COUNT} fruit_t;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* fruits[] = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>};</div><div class="line"></div><div class="line">fruit_t fruit = (fruit_t)<a class="code" href="group__expect.html#ga65a2a909774f3205887ae446ea4089f0">mpack_expect_enum</a>(reader, fruits, COUNT);</div></div><!-- fragment --><p>See <a class="el" href="md_docs_expect.html">Using the Expect API</a> for more examples.</p>
<p>The maximum string length is the size of the buffer (strings are read in-place.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The reader </td></tr>
    <tr><td class="paramname">strings</td><td>An array of expected strings of length count </td></tr>
    <tr><td class="paramname">count</td><td>The number of strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the matched string, or <em>count</em> in case of error </dd></dl>

</div>
</div>
<a class="anchor" id="ga5763a0063111ffdfe8f193fb42e7fea4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_expect_enum_optional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>strings</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expects a string matching one of the strings in the given array returning its array index, or <em>count</em> if no strings match. </p>
<p>If the value is not a string, or it does not match any of the given strings, <em>count</em> is returned and no error is flagged.</p>
<p>If any error occurs or the reader is in an error state, <em>count</em> is returned.</p>
<p>This can be used to quickly parse a string into an enum when the enum values range from 0 to <em>count-1</em>. If the last value in the enum is a special "count" value, it can be passed as the count, and the return value can be cast directly to the enum type.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>           { APPLE ,  BANANA ,  ORANGE , COUNT} fruit_t;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* fruits[] = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>};</div><div class="line"></div><div class="line">fruit_t fruit = (fruit_t)<a class="code" href="group__expect.html#ga5763a0063111ffdfe8f193fb42e7fea4">mpack_expect_enum_optional</a>(reader, fruits, COUNT);</div></div><!-- fragment --><p>See <a class="el" href="md_docs_expect.html">Using the Expect API</a> for more examples.</p>
<p>The maximum string length is the size of the buffer (strings are read in-place.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The reader </td></tr>
    <tr><td class="paramname">strings</td><td>An array of expected strings of length count </td></tr>
    <tr><td class="paramname">count</td><td>The number of strings</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the matched string, or <em>count</em> if it does not match or an error occurs </dd></dl>

</div>
</div>
<a class="anchor" id="gaa29ab364a7ae092e93a20b1a24744c0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_false </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a boolean, raising <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> if its value is not <code>false</code>. </p>

</div>
</div>
<a class="anchor" id="ga49c6bea0c4d7e14a636d703ffe304264"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float mpack_expect_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a number, returning the value as a float. </p>
<p>The underlying value can be an integer, float or double; the value is converted to a float.</p>
<dl class="section note"><dt>Note</dt><dd>Reading a double or a large integer with this function can incur a loss of precision.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float, double or integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0fffadf5032a669d582025f5131b53e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float mpack_expect_float_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a number, ensuring that it falls within the given range and returning the value as a float. </p>
<p>The underlying value can be an integer, float or double; the value is converted to a float.</p>
<dl class="section note"><dt>Note</dt><dd>Reading a double or a large integer with this function can incur a loss of precision.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float, double or integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4d56f4be6f5376ebfa6fcd0ebac6cce1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float mpack_expect_float_strict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a float. </p>
<p>The underlying value must be a float, not a double or an integer. This ensures no loss of precision can occur.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gad8ef3886fd34471e00136a672b6cfbfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t mpack_expect_i16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 16-bit signed integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit signed int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga4ac3f09e7eb21aec1926aaff0ca37128"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t mpack_expect_i16_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 16-bit signed integer, ensuring that it is at least zero and at most <em>max_value</em>. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit signed int.</p>
<p>Returns 0 if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga6c4464418c0444854b3ab39785491a4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t mpack_expect_i16_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 16-bit signed integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit signed int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gaddca7f73951f581f0ddf03f6755322cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mpack_expect_i32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 32-bit signed integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit signed int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gacb9b77aa647947a1e47ab851c715cf6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mpack_expect_i32_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 32-bit signed integer, ensuring that it is at least zero and at most <em>max_value</em>. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit signed int.</p>
<p>Returns 0 if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga217f2065c5f039209f93cddbdbf01bee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mpack_expect_i32_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 32-bit signed integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit signed int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gad93d24fe9e68a1dd94054b70095ebcfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpack_expect_i64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 64-bit signed integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit signed int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga7354498073dfd3583db72591931d22a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpack_expect_i64_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 64-bit signed integer, ensuring that it is at least zero and at most <em>max_value</em>. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit signed int.</p>
<p>Returns 0 if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga7f7356f1e0638a076fac1a8db87f4f53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpack_expect_i64_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 64-bit signed integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit signed int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga728dc9cb317871bbf3360361a713d471"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t mpack_expect_i8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an 8-bit signed integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit signed int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga1436e08a6cb710bf11dabff20188f67b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t mpack_expect_i8_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an 8-bit signed integer, ensuring that it is at least zero and at most <em>max_value</em>. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit signed int.</p>
<p>Returns 0 if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gaa553c386f7ad6d05423835d31a439461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t mpack_expect_i8_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an 8-bit signed integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit signed int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gae81b9d03f80e49501c9b9a695489315f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpack_expect_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a signed int. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a signed int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga8992b669afbaffee6ac8f336022611aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_int_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a signed integer, ensuring that it exactly matches the given value. </p>
<p>mpack_error_type is raised if the value is not representable as a signed integer or if it does not exactly match the given value. </p>

</div>
</div>
<a class="anchor" id="ga7a28a0a5daeeb9b4f10d2169d309f5eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpack_expect_int_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an int, ensuring that it is at least zero and at most <em>max_value</em>. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a signed int.</p>
<p>Returns 0 if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga749d58ee5e884bce54b9767e7ee56c39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpack_expect_int_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a signed integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a signed int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gada27a479e6ad56faaa14528d1a3dfb26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_expect_key_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keys</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>found</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expects a string map key matching one of the strings in the given key list, marking it as found in the given bool array and returning its index. </p>
<p>This is a helper for switching among string keys in a map. It is typically used with an enum with names matching the strings in the array to define the key indices. It should be called in the expression of a switch() statement. See <a class="el" href="md_docs_expect.html">Using the Expect API</a> for an example.</p>
<p>The found array must be cleared before expecting the first key. If the flag for a given key is already set when found (i.e. the map contains a duplicate key), mpack_error_invalid is flagged.</p>
<p>If the key is unrecognized, count is returned and no error is flagged. If you want an error on unrecognized keys, flag an error in the default case in your switch; otherwise you must call <a class="el" href="group__reader.html#ga438bb2b85fbbd06cd8f10d5c8079427e" title="Reads and discards the next object. ">mpack_discard()</a> to discard its content.</p>
<p>The maximum key length is the size of the buffer (keys are read in-place.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The reader </td></tr>
    <tr><td class="paramname">keys</td><td>An array of expected string keys of length count </td></tr>
    <tr><td class="paramname">found</td><td>An array of bool flags of length count </td></tr>
    <tr><td class="paramname">count</td><td>The number of values in the keys and found arrays</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="md_docs_expect.html">Using the Expect API</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga78f80d9fabe961d661eabe95732c2d59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_expect_key_uint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>found</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expects an unsigned integer map key between 0 and count-1, marking it as found in the given bool array and returning it. </p>
<p>This is a helper for switching among int keys in a map. It is typically used with an enum to define the key values. It should be called in the expression of a switch() statement. See <a class="el" href="md_docs_expect.html">Using the Expect API</a> for an example.</p>
<p>The found array must be cleared before expecting the first key. If the flag for a given key is already set when found (i.e. the map contains a duplicate key), mpack_error_invalid is flagged.</p>
<p>If the key is not a non-negative integer, or if the key is <em>count</em> or larger, <em>count</em> is returned and no error is flagged. If you want an error on unrecognized keys, flag an error in the default case in your switch; otherwise you must call <a class="el" href="group__reader.html#ga438bb2b85fbbd06cd8f10d5c8079427e" title="Reads and discards the next object. ">mpack_discard()</a> to discard its content.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The reader </td></tr>
    <tr><td class="paramname">found</td><td>An array of bool flags of length count </td></tr>
    <tr><td class="paramname">count</td><td>The number of values in the found array, and one more than the maximum allowed key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="md_docs_expect.html">Using the Expect API</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ga44a2941b8e8ec379748c238fab52bda1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a map, returning its element count. </p>
<p>A number of values follow equal to twice the element count of the map, alternating between keys and values. <a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> must be called once all elements have been read.</p>
<dl class="section note"><dt>Note</dt><dd>Maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This call is dangerous! It does not have a size limit, and it does not have any way of checking whether there is enough data in the message (since the data could be coming from a stream.) When looping through the map's contents, you must check for errors on each iteration of the loop. Otherwise an attacker could craft a message declaring a map of a billion elements which would throw your parsing code into an infinite loop! You should strongly consider using <a class="el" href="group__expect.html#ga36d86c85877f94aa7b493aaa739c8849" title="Reads the start of a map with a number of elements at most max_count, returning its element count...">mpack_expect_map_max()</a> with a safe maximum size instead.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gab66c8c170be1b394b397ccc041d6c133"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_map_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a map of the exact size given. </p>
<p>A number of values follow equal to twice the element count of the map, alternating between keys and values. <a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> must be called once all elements have been read.</p>
<dl class="section note"><dt>Note</dt><dd>Maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a map or if its size does not match the given count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga36d86c85877f94aa7b493aaa739c8849"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_map_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a map with a number of elements at most <em>max_count</em>, returning its element count. </p>
<p>A number of values follow equal to twice the element count of the map, alternating between keys and values. <a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> must be called once all elements have been read.</p>
<dl class="section note"><dt>Note</dt><dd>Maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON.</dd></dl>
<p>Zero is returned if an error occurs.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a map or if its size is greater than max_count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga2aae8867b092afd5a2350d4701687b35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_expect_map_max_or_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nil node or the start of a map with a number of elements at most max_count, returning whether a map was read and placing its number of key/value pairs in count. </p>
<p>If a map was read, a number of values follow equal to twice the element count of the map, alternating between keys and values. <a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> should anlso be called once all elements have been read (only if a map was read.)</p>
<dl class="section note"><dt>Note</dt><dd>Maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON. Consider using <a class="el" href="group__expect.html#gada27a479e6ad56faaa14528d1a3dfb26" title="Expects a string map key matching one of the strings in the given key list, marking it as found in th...">mpack_expect_key_cstr()</a> or <a class="el" href="group__expect.html#ga78f80d9fabe961d661eabe95732c2d59" title="Expects an unsigned integer map key between 0 and count-1, marking it as found in the given bool arra...">mpack_expect_key_uint()</a> to switch on the key; see <a class="el" href="md_docs_expect.html">Using the Expect API</a> for examples.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a map was read successfully; <code>false</code> if nil was read or an error occured. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a nil or map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaee3ac5d2ea0dc864b5898673a67c69ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_expect_map_or_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nil node or the start of a map, returning whether a map was read and placing its number of key/value pairs in count. </p>
<p>If a map was read, a number of values follow equal to twice the element count of the map, alternating between keys and values. <a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> should also be called once all elements have been read (only if a map was read.)</p>
<dl class="section note"><dt>Note</dt><dd>Maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This call is dangerous! It does not have a size limit, and it does not have any way of checking whether there is enough data in the message (since the data could be coming from a stream.) When looping through the map's contents, you must check for errors on each iteration of the loop. Otherwise an attacker could craft a message declaring a map of a billion elements which would throw your parsing code into an infinite loop! You should strongly consider using <a class="el" href="group__expect.html#ga2aae8867b092afd5a2350d4701687b35" title="Reads a nil node or the start of a map with a number of elements at most max_count, returning whether a map was read and placing its number of key/value pairs in count. ">mpack_expect_map_max_or_nil()</a> with a safe maximum size instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a map was read successfully; <code>false</code> if nil was read or an error occured. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a nil or map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa2d131161862c386e9f048ad93fb3d45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_map_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>min_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a map with a number of elements in the given range, returning its element count. </p>
<p>A number of values follow equal to twice the element count of the map, alternating between keys and values. <a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> must be called once all elements have been read.</p>
<dl class="section note"><dt>Note</dt><dd>Maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON.</dd></dl>
<p>min_count is returned if an error occurs.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a map or if its size does not fall within the given range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gada69acbd6803f79cab7573ae9ebc37bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a nil, raising <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> if the value is not nil. </p>

</div>
</div>
<a class="anchor" id="ga6baba88194988c9f423630052d59f7fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a string, returning its size in bytes. </p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object, copying them into the given buffer...">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572" title="Reads bytes from a string, binary blob or extension object in-place in the buffer. ">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaaad37015e0c53704d9356de06b493de6" title="Finishes reading a string. ">mpack_done_str()</a> must be called once all bytes have been read.</p>
<p>NUL bytes are allowed in the string, and no encoding checks are done.</p>
<p>mpack_error_type is raised if the value is not a string. </p>

</div>
</div>
<a class="anchor" id="ga658205c994cf8fce528f4c8a3a957a14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_expect_str_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string of at most the given size, writing it into the given buffer and returning its size in bytes. </p>
<p>This does not add a null-terminator! Use <a class="el" href="group__expect.html#ga94489d03628c1fb1a3d0ac6971600fe8" title="Reads a string into the given buffer, ensures it has no null bytes, and adds a null-terminator at the...">mpack_expect_cstr()</a> to add a null-terminator.</p>
<p>NUL bytes are allowed in the string, and no encoding checks are done. </p>

</div>
</div>
<a class="anchor" id="gac189c3ea2b957e594854fc2c8cae3cbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_str_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a string, raising an error if its length is not exactly the given number of bytes (not including any null-terminator.) </p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object, copying them into the given buffer...">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572" title="Reads bytes from a string, binary blob or extension object in-place in the buffer. ">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaaad37015e0c53704d9356de06b493de6">mpack_done_str()</a> must be called once all bytes have been read.</p>
<p>mpack_error_type is raised if the value is not a string or if its length does not match. </p>

</div>
</div>
<a class="anchor" id="ga3ceade6375ab699c1ef05ef9f5c2ff90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_str_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string, ensuring it exactly matches the given string. </p>
<p>Remember that maps are unordered in JSON. Don't use this for map keys unless the map has only a single key! </p>

</div>
</div>
<a class="anchor" id="ga00a055c4e4c68485757e1eee17f8db85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_str_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the start of a string, raising an error if its length is not at most the given number of bytes (not including any null-terminator.) </p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object, copying them into the given buffer...">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572" title="Reads bytes from a string, binary blob or extension object in-place in the buffer. ">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaaad37015e0c53704d9356de06b493de6">mpack_done_str()</a> must be called once all bytes have been read.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the value is not a string. </td></tr>
    <tr><td class="paramname">mpack_error_too_big</td><td>If the string's length in bytes is larger than the given maximum size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga6e9c48430fa233615ec9b5439f9ed451"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#structmpack__tag__t">mpack_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a MessagePack object header (an MPack tag), expecting it to exactly match the given tag. </p>
<p>If the type is compound (i.e. is a map, array, string, binary or extension type), additional reads are required to get the contained data, and the corresponding done function must be called when done.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the tag does not match</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c" title="Reads bytes from a string, binary blob or extension object, copying them into the given buffer...">mpack_read_bytes()</a> </dd>
<dd>
<a class="el" href="group__reader.html#gaddae460657b9a26207ed34352bff0b06" title="Finishes reading an array. ">mpack_done_array()</a> </dd>
<dd>
<a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a" title="Finishes reading a map. ">mpack_done_map()</a> </dd>
<dd>
<a class="el" href="group__reader.html#gaaad37015e0c53704d9356de06b493de6" title="Finishes reading a string. ">mpack_done_str()</a> </dd>
<dd>
<a class="el" href="group__reader.html#gaa4676c4b0761de4f864fd81c347a15a0" title="Finishes reading a binary data blob. ">mpack_done_bin()</a> </dd>
<dd>
<a class="el" href="group__reader.html#ga5ebed90f6fe9c1d324256d827032702b" title="Finishes reading an extended type binary data blob. ">mpack_done_ext()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gaadfca446696881a598cc4f90892ded88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_true </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a boolean, raising <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> if its value is not <code>true</code>. </p>

</div>
</div>
<a class="anchor" id="gad267aebef43d94bc7891939d1fc2d51a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t mpack_expect_u16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 16-bit unsigned integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit unsigned int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga34cfd4d43ba388ff4f983b35c65c669a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t mpack_expect_u16_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 16-bit unsigned integer, ensuring that it is at most <em>max_value</em>. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit unsigned int.</p>
<p>Returns 0 if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gad6f984713bc3b24b044a99cd6f4e58b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t mpack_expect_u16_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 16-bit unsigned integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit unsigned int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gaccb728859e5944214324a23979fe0aa2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_u32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 32-bit unsigned integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit unsigned int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga4781e89d1712ae950b768362b8e98065"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_u32_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 32-bit unsigned integer, ensuring that it is at most <em>max_value</em>. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit unsigned int.</p>
<p>Returns 0 if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga1e3a8ce7d88676ed38f7d4aaf22d0d9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_u32_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 32-bit unsigned integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit unsigned int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gab2dbbc0830bc08f2e7ce851782ec06e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mpack_expect_u64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 64-bit unsigned integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit unsigned int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gac5babd6ebf912abb4ed67ca8808f3ad0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mpack_expect_u64_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 64-bit unsigned integer, ensuring that it is at most <em>max_value</em>. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit unsigned int.</p>
<p>Returns 0 if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga7110dc658b713b292e9cafee3ccb7424"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mpack_expect_u64_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a 64-bit unsigned integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit unsigned int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gab1310dc54c39ac7754ee62d635a82976"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t mpack_expect_u8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an 8-bit unsigned integer. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit unsigned int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga61459cbdd02c5b3db5292f9753a03ced"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t mpack_expect_u8_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an 8-bit unsigned integer, ensuring that it is at most <em>max_value</em>. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit unsigned int.</p>
<p>Returns 0 if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gab3922088844e8cb301a6c2a5c5750d4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t mpack_expect_u8_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an 8-bit unsigned integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit unsigned int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gab217c0e2062b87129f948c6359c3825a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mpack_expect_uint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an unsigned int. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an unsigned int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga005303e0b2c39809fcd5172228fae282"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_uint_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an unsigned integer, ensuring that it exactly matches the given value. </p>
<p>mpack_error_type is raised if the value is not representable as an unsigned integer or if it does not exactly match the given value. </p>

</div>
</div>
<a class="anchor" id="ga279a98fc2bb44cbf837fafc70df35bef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mpack_expect_uint_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an unsigned integer, ensuring that it is at most <em>max_value</em>. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an unsigned int.</p>
<p>Returns 0 if an error occurs. </p>

</div>
</div>
<a class="anchor" id="gaa42508b6153a3531961eb69c38d48bbc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mpack_expect_uint_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads an unsigned integer, ensuring that it falls within the given range. </p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an unsigned int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a class="anchor" id="ga8c44c450649514ee1a31e567d39f0bf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_expect_utf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string into the given buffer, ensuring it is a valid UTF-8 string and returning its size in bytes. </p>
<p>This does not add a null-terminator! Use <a class="el" href="group__expect.html#ga62be63032f3c84181eeed4609f0dddb4" title="Reads a string into the given buffer, ensures it is a valid UTF-8 string without NUL characters...">mpack_expect_utf8_cstr()</a> to add a null-terminator.</p>
<p>This does not accept any UTF-8 variant such as Modified UTF-8, CESU-8 or WTF-8. Only pure UTF-8 is allowed.</p>
<p>NUL bytes are allowed in the string (as they are in UTF-8.)</p>
<p>Raises mpack_error_too_big if there is not enough room for the string. Raises mpack_error_type if the value is not a string or is not a valid UTF-8 string. </p>

</div>
</div>
<a class="anchor" id="ga62be63032f3c84181eeed4609f0dddb4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_utf8_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string into the given buffer, ensures it is a valid UTF-8 string without NUL characters, and adds a null-terminator at the end. </p>
<p>This does not accept any UTF-8 variant such as Modified UTF-8, CESU-8 or WTF-8. Only pure UTF-8 is allowed, but without the NUL character, since it cannot be represented in a null-terminated string.</p>
<p>Raises mpack_error_too_big if there is not enough room for the string and null-terminator. Raises mpack_error_type if the value is not a string or is not a valid UTF-8 string. </p>

</div>
</div>
<a class="anchor" id="ga5acb7f64d13ce1a09670377cbbbf68c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_expect_utf8_cstr_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a string with the given total maximum size (including space for a null-terminator), allocates storage for it, ensures it is valid UTF-8 with no null-bytes, and adds a null-terminator at the end. </p>
<p>You assume ownership of the returned pointer if reading succeeds.</p>
<p>The length in bytes of the string, not including the null-terminator, will be written to size.</p>
<p>This does not accept any UTF-8 variant such as Modified UTF-8, CESU-8 or WTF-8. Only pure UTF-8 is allowed, but without the NUL character, since it cannot be represented in a null-terminated string.</p>
<p>The allocated string must be freed with <a class="el" href="group__config.html#ga298d7c2e4093bcfe361088df9e35956a" title="Defines the memory free function used by MPack. ">MPACK_FREE()</a> (or simply free() if MPack's allocator hasn't been customized.) if you want a null-terminator.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_too_big</td><td>if the string plus null-terminator is larger than the given maxsize. </td></tr>
    <tr><td class="paramname">mpack_error_invalid</td><td>if the value is not a string or contains invalid UTF-8 or a null byte. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
